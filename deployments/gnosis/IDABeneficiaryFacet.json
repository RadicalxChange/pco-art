{
  "address": "0x59aEeFC8421D59f260a5E5b959BFcc86B59C8415",
  "abi": [
    {
      "inputs": [],
      "name": "ERC165Base__InvalidInterfaceId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UintUtils__InsufficientHexLength",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "subscriber",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "units",
          "type": "uint128"
        }
      ],
      "name": "BeneficiaryUnitsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Distributed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "TokenSet",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "distribute",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISETH",
          "name": "_token",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "subscriber",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "units",
              "type": "uint128"
            }
          ],
          "internalType": "struct IIDABeneficiaryInternal.Beneficiary[]",
          "name": "_beneficiaries",
          "type": "tuple[]"
        }
      ],
      "name": "initializeIDABeneficiary",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract ISETH",
          "name": "_token",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "subscriber",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "units",
              "type": "uint128"
            }
          ],
          "internalType": "struct IIDABeneficiaryInternal.Beneficiary[]",
          "name": "_beneficiaries",
          "type": "tuple[]"
        }
      ],
      "name": "initializeIDABeneficiary",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "subscriber",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "units",
              "type": "uint128"
            }
          ],
          "internalType": "struct IIDABeneficiaryInternal.Beneficiary[]",
          "name": "_beneficiaries",
          "type": "tuple[]"
        }
      ],
      "name": "updateBeneficiaryUnits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf9e6d76721b6caceff4fc347648681e4f3f4aadeab1615d4e8a942183a130e25",
  "receipt": {
    "to": null,
    "from": "0xfF5Be16460704eFd0263dB1444Eaa216b77477c5",
    "contractAddress": "0x59aEeFC8421D59f260a5E5b959BFcc86B59C8415",
    "transactionIndex": 3,
    "gasUsed": "1130648",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd8aa233cba5cd114a8f8083e855b0a8b2769df706f092e4b4f2d8b724c2757a7",
    "transactionHash": "0xf9e6d76721b6caceff4fc347648681e4f3f4aadeab1615d4e8a942183a130e25",
    "logs": [],
    "blockNumber": 29759650,
    "cumulativeGasUsed": "1683400",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "c548b1a12c4a5b4508c1d2fe38e3b576",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UintUtils__InsufficientHexLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"units\",\"type\":\"uint128\"}],\"name\":\"BeneficiaryUnitsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISETH\",\"name\":\"_token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"units\",\"type\":\"uint128\"}],\"internalType\":\"struct IIDABeneficiaryInternal.Beneficiary[]\",\"name\":\"_beneficiaries\",\"type\":\"tuple[]\"}],\"name\":\"initializeIDABeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract ISETH\",\"name\":\"_token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"units\",\"type\":\"uint128\"}],\"internalType\":\"struct IIDABeneficiaryInternal.Beneficiary[]\",\"name\":\"_beneficiaries\",\"type\":\"tuple[]\"}],\"name\":\"initializeIDABeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"units\",\"type\":\"uint128\"}],\"internalType\":\"struct IIDABeneficiaryInternal.Beneficiary[]\",\"name\":\"_beneficiaries\",\"type\":\"tuple[]\"}],\"name\":\"updateBeneficiaryUnits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Beneficiary implemented using a Superfluid IDA index\",\"kind\":\"dev\",\"methods\":{},\"title\":\"IDABeneficiaryFacet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"distribute()\":{\"notice\":\"Distribute to beneficiaries\"},\"initializeIDABeneficiary(address,(address,uint128)[])\":{\"notice\":\"Initialize beneficiary\"},\"initializeIDABeneficiary(address,address,(address,uint128)[])\":{\"notice\":\"Initialize beneficiary\"},\"updateBeneficiaryUnits((address,uint128)[])\":{\"notice\":\"Update beneficiaries\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/beneficiary/facets/IDABeneficiaryFacet.sol\":\"IDABeneficiaryFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x385a7061f1436b079d44c140dee9387d5313e94874ff9ee877dc0085c981ac3d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/AccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\\nimport { UintUtils } from '../../utils/UintUtils.sol';\\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\\nimport { AccessControlStorage } from './AccessControlStorage.sol';\\n\\n/**\\n * @title Role-based access control system\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nabstract contract AccessControlInternal is IAccessControlInternal {\\n    using AddressUtils for address;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using UintUtils for uint256;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /*\\n     * @notice query whether role is assigned to account\\n     * @param role role to query\\n     * @param account account to query\\n     * @return whether role is assigned to account\\n     */\\n    function _hasRole(\\n        bytes32 role,\\n        address account\\n    ) internal view virtual returns (bool) {\\n        return\\n            AccessControlStorage.layout().roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @notice revert if sender does not have given role\\n     * @param role role to query\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice revert if given account does not have given role\\n     * @param role role to query\\n     * @param account to query\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        'AccessControl: account ',\\n                        account.toString(),\\n                        ' is missing role ',\\n                        uint256(role).toHexString(32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /*\\n     * @notice query admin role for given role\\n     * @param role role to query\\n     * @return admin role\\n     */\\n    function _getRoleAdmin(\\n        bytes32 role\\n    ) internal view virtual returns (bytes32) {\\n        return AccessControlStorage.layout().roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @notice set role as admin role\\n     * @param role role to set\\n     * @param adminRole admin role to set\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin(role);\\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /*\\n     * @notice assign role to given account\\n     * @param role role to assign\\n     * @param account recipient of role assignment\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.add(account);\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /*\\n     * @notice unassign role from given account\\n     * @param role role to unassign\\n     * @parm account\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        AccessControlStorage.layout().roles[role].members.remove(account);\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /**\\n     * @notice relinquish role\\n     * @param role role to relinquish\\n     */\\n    function _renounceRole(bytes32 role) internal virtual {\\n        _revokeRole(role, msg.sender);\\n    }\\n\\n    /**\\n     * @notice query role for member at given index\\n     * @param role role to query\\n     * @param index index to query\\n     */\\n    function _getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) internal view virtual returns (address) {\\n        return AccessControlStorage.layout().roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @notice query role for member count\\n     * @param role role to query\\n     */\\n    function _getRoleMemberCount(\\n        bytes32 role\\n    ) internal view virtual returns (uint256) {\\n        return AccessControlStorage.layout().roles[role].members.length();\\n    }\\n}\\n\",\"keccak256\":\"0x313d74202592af8c7a890c051959b58a3e016b9d0b263d03887a39f2bce27f76\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/AccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\\n\\nlibrary AccessControlStorage {\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct Layout {\\n        mapping(bytes32 => RoleData) roles;\\n    }\\n\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.AccessControl');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xae788d37a6e20edf7f94be23d78517324f50bccbf0541e10ce0850d7d5bca062\",\"license\":\"MIT\"},\"@solidstate/contracts/access/access_control/IAccessControlInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial AccessControl interface needed by internal functions\\n */\\ninterface IAccessControlInternal {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n}\\n\",\"keccak256\":\"0xcc4a1d78a60955d673104adaee1211de3b3cfb95668f1fbfc43ed0e7f36ad110\",\"license\":\"MIT\"},\"@solidstate/contracts/data/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    error EnumerableSet__IndexOutOfBounds();\\n\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(\\n        Bytes32Set storage set,\\n        uint256 index\\n    ) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(\\n        AddressSet storage set,\\n        uint256 index\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(\\n        UintSet storage set,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(\\n        AddressSet storage set,\\n        address value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal view returns (uint256) {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(\\n        Bytes32Set storage set,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(\\n        AddressSet storage set,\\n        address value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(\\n        UintSet storage set,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function toArray(\\n        Bytes32Set storage set\\n    ) internal view returns (bytes32[] memory) {\\n        return set._inner._values;\\n    }\\n\\n    function toArray(\\n        AddressSet storage set\\n    ) internal view returns (address[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        address[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function toArray(\\n        UintSet storage set\\n    ) internal view returns (uint256[] memory) {\\n        bytes32[] storage values = set._inner._values;\\n        uint256[] storage array;\\n\\n        assembly {\\n            array.slot := values.slot\\n        }\\n\\n        return array;\\n    }\\n\\n    function _at(\\n        Set storage set,\\n        uint256 index\\n    ) private view returns (bytes32) {\\n        if (index >= set._values.length)\\n            revert EnumerableSet__IndexOutOfBounds();\\n        return set._values[index];\\n    }\\n\\n    function _contains(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(\\n        Set storage set,\\n        bytes32 value\\n    ) private view returns (uint256) {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            status = true;\\n        }\\n    }\\n\\n    function _remove(\\n        Set storage set,\\n        bytes32 value\\n    ) private returns (bool status) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            unchecked {\\n                bytes32 last = set._values[set._values.length - 1];\\n\\n                // move last value to now-vacant index\\n\\n                set._values[valueIndex - 1] = last;\\n                set._indexes[last] = valueIndex;\\n            }\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            status = true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbbaaeb805b3e1e704ceba33c9093285220254b1ff6b4b7f577e515b118e116f6\",\"license\":\"MIT\"},\"@solidstate/contracts/interfaces/IERC165Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title ERC165 interface registration interface\\n */\\ninterface IERC165Internal {\\n\\n}\\n\",\"keccak256\":\"0xf4d4708a60ed04887849509a258db49d4eb686f33214cb9c9643325cd8dae89d\",\"license\":\"MIT\"},\"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\\n    /**\\n     * @notice indicates whether an interface is already supported based on the interfaceId\\n     * @param interfaceId id of interface to check\\n     * @return bool indicating whether interface is supported\\n     */\\n    function _supportsInterface(\\n        bytes4 interfaceId\\n    ) internal view virtual returns (bool) {\\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @notice sets status of interface support\\n     * @param interfaceId id of interface to set status for\\n     * @param status boolean indicating whether interface will be set as supported\\n     */\\n    function _setSupportsInterface(\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal virtual {\\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\",\"keccak256\":\"0xad163d89454d9c8a018880253c5be156ee0f847f05a392a12b2a7061c7fa8682\",\"license\":\"MIT\"},\"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary ERC165BaseStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfd1cfba40f8aabda5898ffe21adeeea8c7011da12bfdad7f7aa0cf87b3635653\",\"license\":\"MIT\"},\"@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\\n\\ninterface IERC165BaseInternal is IERC165Internal {\\n    error ERC165Base__InvalidInterfaceId();\\n}\\n\",\"keccak256\":\"0xccda4b118c8c09c276a0e577168aa404ea6207aad6b384b04f5f3a8923316422\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/AddressUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    error AddressUtils__InsufficientBalance();\\n    error AddressUtils__NotContract();\\n    error AddressUtils__SendValueFailed();\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        if (!success) revert AddressUtils__SendValueFailed();\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        if (value > address(this).balance)\\n            revert AddressUtils__InsufficientBalance();\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    /**\\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\\n     * @param target recipient of call\\n     * @param gasAmount gas allowance for call\\n     * @param value native token value to include in call\\n     * @param maxCopy maximum number of bytes to copy from return data\\n     * @param data encoded call data\\n     * @return success whether call is successful\\n     * @return returnData copied return data\\n     */\\n    function excessivelySafeCall(\\n        address target,\\n        uint256 gasAmount,\\n        uint256 value,\\n        uint16 maxCopy,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        returnData = new bytes(maxCopy);\\n\\n        assembly {\\n            // execute external call via assembly to avoid automatic copying of return data\\n            success := call(\\n                gasAmount,\\n                target,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n\\n            // determine whether to limit amount of data to copy\\n            let toCopy := returndatasize()\\n\\n            if gt(toCopy, maxCopy) {\\n                toCopy := maxCopy\\n            }\\n\\n            // store the length of the copied bytes\\n            mstore(returnData, toCopy)\\n\\n            // copy the bytes from returndata[0:toCopy]\\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\\n        }\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        if (!isContract(target)) revert AddressUtils__NotContract();\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf\",\"license\":\"MIT\"},\"@solidstate/contracts/utils/UintUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    error UintUtils__InsufficientHexLength();\\n\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? sub(a, -b) : a + uint256(b);\\n    }\\n\\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\\n        return b < 0 ? add(a, -b) : a - uint256(b);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(\\n        uint256 value,\\n        uint256 length\\n    ) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        if (value != 0) revert UintUtils__InsufficientHexLength();\\n\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\n\\nimport {\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\n/**\\n * @title Library for Token Centric Interface\\n * @author Superfluid\\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\\n * of ISuperToken\\n */\\nlibrary SuperTokenV1Library {\\n\\n    /** CFA BASE CRUD ************************************* */\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The userdata passed along with call\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** CFA ACL ************************************* */\\n\\n    /**\\n     * @dev Update permissions for flow operator\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     */\\n    function setFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function setMaxFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function revokeFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator in callback\\n     * @notice allowing userData to be a parameter here triggered stack to deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissionsBitmask,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setMaxFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n    * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Updates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n     /**\\n     * @dev Deletes flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /** CFA With CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The receiver of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** CFA VIEW FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev get flow rate between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return flowRate The flow rate\\n     */\\n    function getFlowRate(ISuperToken token, address sender, address receiver)\\n        internal view returns(int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getNetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getNetFlowInfo(ISuperToken token, address account)\\n        internal view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev calculate buffer for a flow rate\\n     * @param token The token used in flow\\n     * @param flowRate The flowrate to calculate the needed buffer for\\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\\n     */\\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\\n        returns (uint256 bufferAmount)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\\n    }\\n\\n    /**\\n     * @dev get existing flow permissions\\n     * @param token The token used in flow\\n     * @param sender sender of a flow\\n     * @param flowOperator the address we are checking permissions of for sender & token\\n     * @return allowCreate is true if the flowOperator can create flows\\n     * @return allowUpdate is true if the flowOperator can update flows\\n     * @return allowDelete is true if the flowOperator can delete flows\\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\\n     */\\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\\n        internal view\\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        uint8 permissionsBitmask;\\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\\n        allowCreate = permissionsBitmask & 1 == 1 ? true : false;\\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1 ? true : false;\\n        allowDelete = permissionsBitmask >> 2 & 1 == 1 ? true : false;\\n    }\\n\\n\\n     /** IDA VIEW FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Gets an index by its ID and publisher.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @return exist True if the index exists.\\n     * @return indexValue Total value of the index.\\n     * @return totalUnitsApproved Units of the index approved by subscribers.\\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n     */\\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\\n        internal view\\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /**\\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount of tokens desired to distribute.\\n     * @return actualAmount Amount to be distributed with correct rounding.\\n     * @return newIndexValue The index value after the distribution would be called.\\n     */\\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\\n        internal view\\n        returns (uint256 actualAmount, uint128 newIndexValue)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /**\\n     * @dev List all subscriptions of an address\\n     * @param token Super token used in the indexes listed.\\n     * @param subscriber Subscriber address.\\n     * @return publishers Publishers of the indices.\\n     * @return indexIds IDs of the indices.\\n     * @return unitsList Units owned of the indices.\\n     */\\n    function listSubscriptions(\\n        ISuperToken token,\\n        address subscriber\\n    )\\n        internal view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /**\\n     * @dev Gets subscription by publisher, index id, and subscriber.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber to the index.\\n     * @return exist True if the subscription exists.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\\n        internal view\\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /*\\n     * @dev Gets subscription by the agreement ID.\\n     * @param token Super Token used with the index.\\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\\n     * @return publisher Publisher of the index.\\n     * @return indexId ID of the index.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\\n        internal view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n\\n    /** IDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new index.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates a new index with userData.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n     * passing the new total index value, you pass the amount of tokens desired to be distributed. \\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount - total number of tokens desired to be distributed \\n     * NOTE in many cases, there can be some precision loss \\n     This may cause a slight difference in the amount param specified and the actual amount distributed. \\n     See below for math:\\n     //indexDelta = amount the index will be updated by during an internal call to _updateIndex().\\n     It is calculated like so:\\n     indexDelta = amount / totalUnits \\n     (see the distribute() implementatation in ./agreements/InstantDistributionAgreement.sol)\\n     * NOTE Solidity does not support floating point numbers\\n     So the indexDelta will be rounded down to the nearest integer. \\n     This will create a 'remainder' amount of tokens that will not be distributed \\n     (we'll call this the 'distribution modulo')\\n     distributionModulo = amount - indexDelta * totalUnits\\n     * NOTE due to rounding, there may be a small amount of tokens left in the publisher's account\\n     This amount is equal to the 'distributionModulo' value\\n     //\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** IDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Creates a new index with ctx.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function createIndexWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * Meant for usage in super app callbakcs\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param ctx from super app callback\\n     */\\n    function updateIndexValueWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param ctx from super app callback\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function approveSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function revokeSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param ctx from super app callback\\n     */\\n    function updateSubscriptionUnitsWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\\n     * Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param ctx from super app callback\\n     */\\n    function deleteSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param ctx from super app callback\\n     */\\n    function claimWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    // ************** private helpers **************\\n\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\\\")\\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\\\")\\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\\\");\\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\\n\\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndCFA(ISuperToken token) private\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\")\\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_CFA_SLOT, cfa)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndIDA(ISuperToken token) private\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                    keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_IDA_SLOT, ida)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and cfa addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndCFA(ISuperToken token) private view\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\")\\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndIDA(ISuperToken token) private view\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\")\\n                    0x15609310ae3c30189a1218b7adabaf36c267255e70cf91b6cba384367d9eda32)));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n}\\n\",\"keccak256\":\"0xf8f16374ca1293f5a66d3e2967c3e47f84cdd429190de9dddba1a578c7da45f3\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note \\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        external view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    ) \\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param addedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function increaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 addedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @return newCtx The new context bytes\\n     */\\n    function decreaseFlowRateAllowance(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        int96 subtractedFlowRateAllowance,\\n        bytes calldata ctx\\n    ) external virtual returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks \\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n     \\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0xb68e122faba133422f4cbdd7e15fc913073dfa2c3682c18d6449b121e67d1104\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0x7b088dfa11a00d2b1e6e0938978364a6918015b052a4bf3ffcc67db9b3182370\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appCallbackLevel, uint8 callType)\\n    {\\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\n library FlowOperatorDefinitions {\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n        return (\\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n            ) == uint8(0);\\n    }\\n }\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev ERC777.send batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationSend(\\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\\n    /**\\n     * @dev ERC20.increaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationIncreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 addedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_INCREASE_ALLOWANCE = 4;\\n    /**\\n     * @dev ERC20.decreaseAllowance batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDecreaseAllowance(\\n     *     abi.decode(data, (address account, address spender, uint256 subtractedValue))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_DECREASE_ALLOWANCE = 5;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes callData, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32)\\n    {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure\\n        returns (uint256 liquidationPeriod, uint256 patricianPeriod)\\n    {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0x8c817a6d85868039485ecdf1c7163f2e06be939cfc3923ba4ca6628f614282a1\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantInflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantInflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n    error CIF_NFT_ONLY_CONSTANT_OUTFLOW(); // 0xe81ef57a\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The mint function emits the \\\"mint\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param to the flow receiver (inflow NFT receiver)\\n    /// @param newTokenId the new token id\\n    function mint(address to, uint256 newTokenId) external;\\n\\n    /// @notice This burn function emits the \\\"burn\\\" `Transfer` event.\\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\\n    /// is to inform clients that search for events.\\n    /// @param tokenId desired token id to burn\\n    function burn(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0xb989f0fe54561ecb32f66ac55427d98866c77ee4b6a1da52aca2e0953a7f7f06\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantOutflowNFT.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { IFlowNFTBase } from \\\"./IFlowNFTBase.sol\\\";\\n\\ninterface IConstantOutflowNFT is IFlowNFTBase {\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error COF_NFT_INVALID_SUPER_TOKEN();            // 0x6de98774\\n    error COF_NFT_MINT_TO_AND_FLOW_RECEIVER_SAME(); // 0x0d1d1161\\n    error COF_NFT_MINT_TO_ZERO_ADDRESS();           // 0x43d05e51\\n    error COF_NFT_ONLY_CONSTANT_INFLOW();           // 0xa495a718\\n    error COF_NFT_ONLY_FLOW_AGREEMENTS();           // 0xd367b64f\\n    error COF_NFT_TOKEN_ALREADY_EXISTS();           // 0xe2480183\\n\\n\\n    /**************************************************************************\\n     * Write Functions\\n     *************************************************************************/\\n\\n    /// @notice The onCreate function is called when a new flow is created.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onCreate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onUpdate function is called when a flow is updated.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onUpdate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n\\n    /// @notice The onDelete function is called when a flow is deleted.\\n    /// @param token the super token passed from the CFA (flowVars)\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    function onDelete(ISuperfluidToken token, address flowSender, address flowReceiver) external;\\n}\\n\",\"keccak256\":\"0x5df423f453923ff6f7ee716e7c1c64d2e19743ad77455b0bba23fd28f2a9d587\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IFlowNFTBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\nimport {\\n    IERC721Metadata\\n} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\ninterface IFlowNFTBase is IERC721Metadata {\\n    // FlowNFTData struct storage packing:\\n    // b = bits\\n    // WORD 1: | superToken      | FREE\\n    //         | 160b            | 96b\\n    // WORD 2: | flowSender      | FREE\\n    //         | 160b            | 96b\\n    // WORD 3: | flowReceiver    | flowStartDate | FREE\\n    //         | 160b            | 32b           | 64b\\n    struct FlowNFTData {\\n        address superToken;\\n        address flowSender;\\n        address flowReceiver;\\n        uint32 flowStartDate;\\n    }\\n\\n    /**************************************************************************\\n     * Custom Errors\\n     *************************************************************************/\\n\\n    error CFA_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();   // 0xa3352582\\n    error CFA_NFT_APPROVE_TO_CALLER();                              // 0xd3c77329\\n    error CFA_NFT_APPROVE_TO_CURRENT_OWNER();                       // 0xe4790b25\\n    error CFA_NFT_INVALID_TOKEN_ID();                               // 0xeab95e3b\\n    error CFA_NFT_ONLY_SUPER_TOKEN_FACTORY();                       // 0xebb7505b\\n    error CFA_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x2551d606\\n    error CFA_NFT_TRANSFER_FROM_INCORRECT_OWNER();                  // 0x5a26c744\\n    error CFA_NFT_TRANSFER_IS_NOT_ALLOWED();                        // 0xaa747eca\\n    error CFA_NFT_TRANSFER_TO_ZERO_ADDRESS();                       // 0xde06d21e\\n\\n    /**************************************************************************\\n     * Events\\n     *************************************************************************/\\n\\n    /// @notice Informs third-party platforms that NFT metadata should be updated\\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\\n    /// @param tokenId the id of the token that should have its metadata updated\\n    event MetadataUpdate(uint256 tokenId);\\n\\n    /**************************************************************************\\n     * View\\n     *************************************************************************/\\n\\n    /// @notice An external function for querying flow data by `tokenId``\\n    /// @param tokenId the token id\\n    /// @return flowData the flow data associated with `tokenId`\\n    function flowDataByTokenId(\\n        uint256 tokenId\\n    ) external view returns (FlowNFTData memory flowData);\\n\\n    /// @notice An external function for computing the deterministic tokenId\\n    /// @dev tokenId = uint256(keccak256(abi.encode(block.chainId, superToken, flowSender, flowReceiver)))\\n    /// @param superToken the super token\\n    /// @param flowSender the flow sender\\n    /// @param flowReceiver the flow receiver\\n    /// @return tokenId the tokenId\\n    function getTokenId(\\n        address superToken,\\n        address flowSender,\\n        address flowReceiver\\n    ) external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Write\\n     *************************************************************************/\\n\\n    function initialize(\\n        string memory nftName,\\n        string memory nftSymbol\\n    ) external; // initializer;\\n\\n    function triggerMetadataUpdate(uint256 tokenId) external;\\n}\\n\",\"keccak256\":\"0x1c62c63f39c7c9ba03ddde542690ccfea343b5b3b442ed4cf2830b43af6f9cbe\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolAdminNFT.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\ninterface IPoolAdminNFT {}\",\"keccak256\":\"0x3a93bb86598d8840dc333efce41c0fcc8b839df6597c3be49dcb4e3d4fb9f074\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolMemberNFT.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >=0.8.4;\\n\\ninterface IPoolMemberNFT {}\",\"keccak256\":\"0x5555e072e755dea4ffcd4c0c74d8ca8e7f782d462e049c8eb09171b0edc38394\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0x9b4fab6dcac1337f78e04d67d8c2b48b1de8bd4bbf14b475840f9dbda7b8f21e\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to\\n    *         the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x0182f29b230b034686dc505935ca0a1635fc537274bb592393a6e259010be08b\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IConstantOutflowNFT } from \\\"./IConstantOutflowNFT.sol\\\";\\nimport { IConstantInflowNFT } from \\\"./IConstantInflowNFT.sol\\\";\\nimport { IPoolAdminNFT } from \\\"./IPoolAdminNFT.sol\\\";\\nimport { IPoolMemberNFT } from \\\"./IPoolMemberNFT.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\\n    error SUPER_TOKEN_ONLY_GOV_OWNER();                          // 0xd9c7ed08\\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\\n    error SUPER_TOKEN_NFT_PROXY_ADDRESS_CHANGED();               // 0x6bef249d\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * Immutable variables\\n    *************************************************************************/\\n    function CONSTANT_OUTFLOW_NFT() external view returns (IConstantOutflowNFT);\\n    function CONSTANT_INFLOW_NFT() external view returns (IConstantInflowNFT);\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `data` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply and transfers the underlying token to the caller's account.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * @custom:modifiers \\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to receive upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     * \\n     * @custom:warning\\n     * - there is potential of reentrancy IF the \\\"to\\\" account is a registered ERC777 recipient.\\n     * @custom:requirements \\n     * - if `data` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient otherwise it reverts.\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\\n     * @param to The account to receive downgraded tokens\\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\\n     */\\n    function downgradeTo(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are downgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function operationIncreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 addedValue\\n    ) external;\\n\\n    function operationDecreaseAllowance(\\n        address account,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transferFrom by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC777 send by host contract.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    * @param data Arbitrary user inputted data\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationSend(\\n        address spender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n    // Flow NFT events\\n    /**\\n     * @dev Constant Outflow NFT proxy created event\\n     * @param constantOutflowNFT constant outflow nft address\\n     */\\n    event ConstantOutflowNFTCreated(\\n        IConstantOutflowNFT indexed constantOutflowNFT\\n    );\\n\\n    /**\\n     * @dev Constant Inflow NFT proxy created event\\n     * @param constantInflowNFT constant inflow nft address\\n     */\\n    event ConstantInflowNFTCreated(\\n        IConstantInflowNFT indexed constantInflowNFT\\n    );\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xc179b68b0641e7fa8873d77a4f3bb1116533e5da1120683fe5ee4bb6419d38d2\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS();                 // 0x91d67972\\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST();                 // 0x872cac48\\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();                  // 0x1b39b9b4\\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();                      // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_NON_UPGRADEABLE_IS_DEPRECATED();  // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();                   // 0x305c9e82\\n\\n    /**************************************************************************\\n    * Immutable Variables\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @notice Get the canonical super token logic.\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABLE\\n    }\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\\n     * @param _underlyingToken Underlying ERC20 token\\n     * @return ISuperToken the created supertoken\\n     */\\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\\n        external\\n        returns (ISuperToken);\\n\\n    /**\\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\\n     * @param _underlyingToken Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\\n     */\\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\\n        external\\n        view\\n        returns (address superTokenAddress, bool isDeployed);\\n\\n    /**\\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\\n     * @dev We return the address if it exists and the zero address otherwise\\n     * @param _underlyingTokenAddress Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     */\\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\\n        external\\n        view\\n        returns (address superTokenAddress);\\n\\n    /**\\n     * @dev Creates a new custom super token\\n     * @param customSuperTokenProxy address of the custom supertoken proxy\\n     */\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\",\"keccak256\":\"0xac57bbc7e9432bf926d4f9913b71301b18b4519de12e22892ebbc646d43b88c5\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    BatchOperation,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    SuperAppDefinitions,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    // Superfluid Custom Errors\\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\\n\\n    // App Related Custom Errors\\n    // uses SuperAppDefinitions' App Jail Reasons as _code\\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\\n\\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers \\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers \\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n    /**\\n     * @dev SuperToken logic updated event\\n     * @param code Address of the new SuperToken logic\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app callbacklevel\\n     * @param app Super app address\\n     */\\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app credit and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appCreditGranted        App credit granted so far.\\n     * @param  appCreditUsed           App credit used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appCreditGranted,\\n        int256 appCreditUsed,\\n        ISuperfluidToken appCreditToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appCreditUsedDelta      App credit used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appCreditUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app credit.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appCreditUsedMore        See app credit for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseCredit(\\n        bytes calldata ctx,\\n        int256 appCreditUsedMore\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // app callback level\\n        uint8 appCallbackLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app credit granted\\n        uint256 appCreditGranted;\\n        // app credit wanted by the app callback\\n        uint256 appCreditWantedDeprecated;\\n        // app credit used, allowing negative values over a callback session\\n        // the appCreditUsed value over a callback sessions is calculated with:\\n        // existing flow data owed deposit + sum of the callback agreements\\n        // deposit deltas \\n        // the final value used to modify the state is determined by the\\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes \\n        // the appCreditUsed value reached in the callback session and the app\\n        // credit granted\\n        int256 appCreditUsed;\\n        // app address\\n        address appAddress;\\n        // app credit in super token\\n        ISuperfluidToken appCreditToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes memory ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] calldata operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] calldata operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0xab9dab941f99d0f0ef6125fb6eafde03378d7c3e94e613dd12fb7fbf594c3373\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n    \\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_GOV_ARRAYS_NOT_SAME_LENGTH();                  // 0x27743aa6\\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note \\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n    \\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n    \\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0x90a9259d0f0bb6b1bb6d48f051277eb75df96a9fbe684a203a3a468ad19318e2\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x9cad3866982902ea88df0874a563d2e4aeba5a5bcc6289c30cccf9b4099d2fb6\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x55be78ffb441c782f612b153d7d9049e3f0dbfd412c1f7df29c896b972b2985f\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperToken } from \\\"../superfluid/ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Super ETH (SETH) custom token interface\\n * @author Superfluid\\n */\\ninterface ISETHCustom {\\n    // using native token\\n    function upgradeByETH() external payable;\\n    function upgradeByETHTo(address to) external payable;\\n    function downgradeToETH(uint wad) external;\\n}\\n\\n/**\\n * @title Super ETH (SETH) full interface\\n * @author Superfluid\\n */\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISETH is ISETHCustom, ISuperToken {}\\n\",\"keccak256\":\"0x03d0c332b2dec2453fe1dfa879cb40cba5075a02f4b08740f0e6ba10f80bd577\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x7456cd394cc905aae7cdbd4601ce1c296c768c13c28e66efbb913cc070bad3e4\",\"license\":\"AGPLv3\"},\"contracts/beneficiary/IBeneficiary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/**\\n * @title IBeneficiary\\n */\\ninterface IBeneficiary {\\n    /**\\n     * @notice Distribute to beneficiaries\\n     */\\n    function distribute() external payable;\\n}\\n\",\"keccak256\":\"0x990ff66ef226d9eaf11ab33e4f4f1460515b4657ed512f4822ff284d425ebcc6\",\"license\":\"MIT\"},\"contracts/beneficiary/IDABeneficiaryInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\\nimport { SuperTokenV1Library } from '@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol';\\nimport { IDABeneficiaryStorage } from './IDABeneficiaryStorage.sol';\\nimport { IIDABeneficiaryInternal } from './IIDABeneficiaryInternal.sol';\\n\\n/**\\n * @title IDABeneficiaryInternal\\n */\\nabstract contract IDABeneficiaryInternal is IIDABeneficiaryInternal {\\n    using SuperTokenV1Library for ISETH;\\n\\n    /**\\n     * @notice Initialize beneficiary\\n     */\\n    function _initializeIDABeneficiary(\\n        ISETH _token,\\n        Beneficiary[] memory _beneficiaries\\n    ) internal {\\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\\n\\n        l.isInitialized = true;\\n\\n        _setToken(_token);\\n        _updateBeneficiaryUnits(_beneficiaries);\\n    }\\n\\n    /**\\n     * @notice Check if initialized\\n     */\\n    function _isInitialized() internal view returns (bool) {\\n        return IDABeneficiaryStorage.layout().isInitialized;\\n    }\\n\\n    /**\\n     * @notice Set token\\n     */\\n    function _setToken(ISETH _token) internal {\\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\\n\\n        emit TokenSet(address(_token));\\n\\n        l.token = _token;\\n        //slither-disable-next-line unused-return\\n        l.token.createIndex(0);\\n    }\\n\\n    /**\\n     * @notice Update beneficiary units\\n     */\\n    function _updateBeneficiaryUnits(\\n        Beneficiary[] memory _beneficiaries\\n    ) internal {\\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\\n\\n        //slither-disable-start reentrancy-events\\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\\n            emit BeneficiaryUnitsUpdated(\\n                _beneficiaries[i].subscriber,\\n                _beneficiaries[i].units\\n            );\\n\\n            //slither-disable-next-line unused-return\\n            l.token.updateSubscriptionUnits(\\n                0,\\n                _beneficiaries[i].subscriber,\\n                _beneficiaries[i].units\\n            );\\n        }\\n        //slither-disable-end reentrancy-events\\n    }\\n\\n    /**\\n     * @notice Distribute to beneficiaries\\n     */\\n    function _distribute(uint256 value) internal {\\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\\n\\n        emit Distributed(value);\\n\\n        // Wrap ETH\\n        l.token.upgradeByETH{ value: value }();\\n\\n        // Distribute to beneficiaries\\n        //slither-disable-next-line unused-return\\n        l.token.distribute(0, value);\\n    }\\n}\\n\",\"keccak256\":\"0xaf1383e3bfe2fc8b89f331b5f7aad133733051e9b93a8138bd5ca0c2d05d1a26\",\"license\":\"MIT\"},\"contracts/beneficiary/IDABeneficiaryStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\\n\\n/**\\n * @title IDABeneficiaryStorage\\n */\\nlibrary IDABeneficiaryStorage {\\n    struct Layout {\\n        bool isInitialized;\\n        ISETH token;\\n    }\\n\\n    bytes32 private constant STORAGE_SLOT =\\n        keccak256('pcoart.contracts.storage.IDABeneficiaryStorage');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        //slither-disable-next-line assembly\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1041d69c84b79f5f9b5290cccf5a7dd87a71bc889e84196449763847f32ed728\",\"license\":\"MIT\"},\"contracts/beneficiary/IIDABeneficiary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { IBeneficiary } from './IBeneficiary.sol';\\nimport { IIDABeneficiaryInternal } from './IIDABeneficiaryInternal.sol';\\n\\n/**\\n * @title IIDABeneficiary\\n */\\ninterface IIDABeneficiary is IBeneficiary, IIDABeneficiaryInternal {\\n    /**\\n     * @notice Update beneficiary units\\n     */\\n    function updateBeneficiaryUnits(\\n        Beneficiary[] memory _beneficiaries\\n    ) external;\\n}\\n\",\"keccak256\":\"0x4fbcb05f8aad41a302b5b58efed21f564b1f64d49821bbe40015ba244e9da4cd\",\"license\":\"MIT\"},\"contracts/beneficiary/IIDABeneficiaryInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/**\\n * @title IIDABeneficiaryInternal\\n */\\ninterface IIDABeneficiaryInternal {\\n    struct Beneficiary {\\n        address subscriber;\\n        uint128 units;\\n    }\\n\\n    event TokenSet(address indexed token);\\n    event BeneficiaryUnitsUpdated(address indexed subscriber, uint128 units);\\n    event Distributed(uint256 amount);\\n}\\n\",\"keccak256\":\"0x7af25073a90496b23e45d4153470ed731c2c536df42c2593f60d4e9b45a5d5ef\",\"license\":\"MIT\"},\"contracts/beneficiary/facets/IDABeneficiaryFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\\nimport { SuperTokenV1Library } from '@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol';\\nimport { IIDABeneficiary } from '../IIDABeneficiary.sol';\\nimport { IDABeneficiaryInternal } from '../IDABeneficiaryInternal.sol';\\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\\nimport { IBeneficiary } from '../IBeneficiary.sol';\\n\\n/**\\n * @title IDABeneficiaryFacet\\n * @dev Beneficiary implemented using a Superfluid IDA index\\n */\\ncontract IDABeneficiaryFacet is\\n    IIDABeneficiary,\\n    IDABeneficiaryInternal,\\n    AccessControlInternal,\\n    ERC165BaseInternal\\n{\\n    using SuperTokenV1Library for ISETH;\\n\\n    // Component role\\n    bytes32 internal constant COMPONENT_ROLE =\\n        keccak256('IDABeneficiaryFacet.COMPONENT_ROLE');\\n\\n    /**\\n     * @notice Initialize beneficiary\\n     */\\n    function initializeIDABeneficiary(\\n        ISETH _token,\\n        Beneficiary[] memory _beneficiaries\\n    ) external {\\n        require(!_isInitialized(), 'IDABeneficiaryFacet: already initialized');\\n\\n        _setSupportsInterface(type(IBeneficiary).interfaceId, true);\\n        _initializeIDABeneficiary(_token, _beneficiaries);\\n    }\\n\\n    /**\\n     * @notice Initialize beneficiary\\n     */\\n    function initializeIDABeneficiary(\\n        address _owner,\\n        ISETH _token,\\n        Beneficiary[] memory _beneficiaries\\n    ) external {\\n        require(!_isInitialized(), 'IDABeneficiaryFacet: already initialized');\\n\\n        _setSupportsInterface(type(IBeneficiary).interfaceId, true);\\n        _setSupportsInterface(type(IIDABeneficiary).interfaceId, true);\\n        _grantRole(COMPONENT_ROLE, _owner);\\n        _initializeIDABeneficiary(_token, _beneficiaries);\\n    }\\n\\n    /**\\n     * @notice Update beneficiaries\\n     */\\n    function updateBeneficiaryUnits(\\n        Beneficiary[] memory _beneficiaries\\n    ) external onlyRole(COMPONENT_ROLE) {\\n        _updateBeneficiaryUnits(_beneficiaries);\\n    }\\n\\n    /**\\n     * @notice Distribute to beneficiaries\\n     */\\n    function distribute() external payable {\\n        require(\\n            msg.value > 0,\\n            'IDABeneficiaryFacet: msg.value should be greater than 0'\\n        );\\n\\n        _distribute(msg.value);\\n    }\\n}\\n\",\"keccak256\":\"0xa30d70726a0e19dc054db825cb845eb33db7e25b49fb659ea952712f2d7863b0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061137e806100206000396000f3fe60806040526004361061003f5760003560e01c806307cbd36c14610044578063172cedd614610066578063af5bcdac14610086578063e4fc6b6d146100a6575b600080fd5b34801561005057600080fd5b5061006461005f366004610ecc565b6100ae565b005b34801561007257600080fd5b50610064610081366004610f09565b6100e5565b34801561009257600080fd5b506100646100a1366004610f59565b61013a565b6100646101c7565b7f84882401b15b07d66e021ce83aef83bb1d37009af2fea3a7c3ed872472642fed6100d881610248565b6100e182610255565b5050565b6000805160206113298339815191525460ff161561011e5760405162461bcd60e51b815260040161011590610fbb565b60405180910390fd5b61013063e4fc6b6d60e01b6001610368565b6100e182826103de565b6000805160206113298339815191525460ff161561016a5760405162461bcd60e51b815260040161011590610fbb565b61017c63e4fc6b6d60e01b6001610368565b61018e6301f2f4db60e21b6001610368565b6101b87f84882401b15b07d66e021ce83aef83bb1d37009af2fea3a7c3ed872472642fed8461040a565b6101c282826103de565b505050565b6000341161023d5760405162461bcd60e51b815260206004820152603760248201527f49444142656e656669636961727946616365743a206d73672e76616c7565207360448201527f686f756c642062652067726561746572207468616e20300000000000000000006064820152608401610115565b6102463461047e565b565b610252813361054a565b50565b60008051602061132983398151915260005b82518110156101c25782818151811061028257610282611003565b6020026020010151600001516001600160a01b03167fa28017dec7757734b2d9df357f162beb25e6b604314dde5986a698a7cda3423d8483815181106102ca576102ca611003565b6020026020010151602001516040516102f291906001600160801b0391909116815260200190565b60405180910390a2610355600084838151811061031157610311611003565b60200260200101516000015185848151811061032f5761032f611003565b6020908102919091018101510151855461010090046001600160a01b03169291906105ac565b50806103608161102f565b915050610267565b6001600160e01b031980831690036103935760405163b0a19dd560e01b815260040160405180910390fd5b6001600160e01b03199190911660009081527ffc606c433378e3a7e0a6a531deac289b66caa1b4aa8554fd4ab2c6f1570f92d860205260409020805460ff1916911515919091179055565b600080516020611329833981519152805460ff19166001178155610401836106d8565b6101c282610255565b60008281527fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c62281160205260409020610441908261074f565b5060405133906001600160a01b0383169084907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d90600090a45050565b604051818152600080516020611329833981519152907fddc9c30275a04c48091f24199f9c405765de34d979d6847f5b9798a57232d2e59060200160405180910390a18060000160019054906101000a90046001600160a01b03166001600160a01b031663cf81464b836040518263ffffffff1660e01b81526004016000604051808303818588803b15801561051357600080fd5b505af1158015610527573d6000803e3d6000fd5b505083546101c2935061010090046001600160a01b03169150600090508461076d565b6105548282610896565b6100e15761056a816001600160a01b03166108ef565b610575836020610901565b60405160200161058692919061106c565b60408051601f198184030181529082905262461bcd60e51b82526101159160040161110d565b60008060006105ba87610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663232d2b588b8b8b8b600067ffffffffffffffff8111156105fb576105fb610d84565b6040519080825280601f01601f191660200182016040528015610625576020820181803683370190505b5060405160240161063a959493929190611120565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261068393925090600401611172565b6000604051808303816000875af11580156106a2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106ca91908101906111b9565b506001979650505050505050565b604051600080516020611329833981519152906001600160a01b038316907fa07c91c183e42229e705a9795a1c06d76528b673788b849597364528c96eefb790600090a28054610100600160a81b0319166101006001600160a01b038481168202929092178084556101c292919004166000610c1b565b6000610764836001600160a01b038416610d41565b90505b92915050565b600080600061077b86610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663b96731c28a8a8a600067ffffffffffffffff8111156107bb576107bb610d84565b6040519080825280601f01601f1916602001820160405280156107e5576020820181803683370190505b506040516024016107f9949392919061124d565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261084293925090600401611172565b6000604051808303816000875af1158015610861573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261088991908101906111b9565b5060019695505050505050565b6000610764827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b03811660009081526001830160205260408120541515610764565b60606107676001600160a01b03831660145b6060600061091083600261128a565b61091b9060026112a9565b67ffffffffffffffff81111561093357610933610d84565b6040519080825280601f01601f19166020018201604052801561095d576020820181803683370190505b509050600360fc1b8160008151811061097857610978611003565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106109a7576109a7611003565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610a34576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106109f7576109f7611003565b1a60f81b828281518110610a0d57610a0d611003565b60200101906001600160f81b031916908160001a90535060049490941c93600019016109c6565b5083156107645760405163c913478560e01b815260040160405180910390fd5b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb546001600160a01b038116610bea576001600160a01b038216610b1957826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1691906112bc565b91505b604051635b69006f60e11b81527f8aedc3b5d4bf031e11a7e2940f7251c005698405d58e02e1c247fed3b1b3a67460048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610b7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba191906112bc565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb555b6001600160a01b038216610c0057610c006112d9565b6001600160a01b038116610c1657610c166112d9565b915091565b6000806000610c2985610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663d787840a8989600067ffffffffffffffff811115610c6857610c68610d84565b6040519080825280601f01601f191660200182016040528015610c92576020820181803683370190505b50604051602401610ca5939291906112ef565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b0319168252610cee93925090600401611172565b6000604051808303816000875af1158015610d0d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d3591908101906111b9565b50600195945050505050565b6000818152600183016020526040812054610767575081546001808201845560008481526020808220909301849055845493815293810190915260409092205590565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610dbd57610dbd610d84565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610dec57610dec610d84565b604052919050565b6001600160a01b038116811461025257600080fd5b600082601f830112610e1a57600080fd5b8135602067ffffffffffffffff821115610e3657610e36610d84565b610e44818360051b01610dc3565b82815260069290921b84018101918181019086841115610e6357600080fd5b8286015b84811015610ec15760408189031215610e805760008081fd5b610e88610d9a565b8135610e9381610df4565b8152818501356001600160801b0381168114610eaf5760008081fd5b81860152835291830191604001610e67565b509695505050505050565b600060208284031215610ede57600080fd5b813567ffffffffffffffff811115610ef557600080fd5b610f0184828501610e09565b949350505050565b60008060408385031215610f1c57600080fd5b8235610f2781610df4565b9150602083013567ffffffffffffffff811115610f4357600080fd5b610f4f85828601610e09565b9150509250929050565b600080600060608486031215610f6e57600080fd5b8335610f7981610df4565b92506020840135610f8981610df4565b9150604084013567ffffffffffffffff811115610fa557600080fd5b610fb186828701610e09565b9150509250925092565b60208082526028908201527f49444142656e656669636961727946616365743a20616c726561647920696e696040820152671d1a585b1a5e995960c21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001820161104157611041611019565b5060010190565b60005b8381101561106357818101518382015260200161104b565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516110a4816017850160208801611048565b7001034b99036b4b9b9b4b733903937b6329607d1b60179184019182015283516110d5816028840160208801611048565b01602801949350505050565b600081518084526110f9816020860160208601611048565b601f01601f19169290920160200192915050565b60208152600061076460208301846110e1565b6001600160a01b03868116825263ffffffff86166020830152841660408201526001600160801b038316606082015260a060808201819052600090611167908301846110e1565b979650505050505050565b6001600160a01b0383168152606060208201819052600090611196908301846110e1565b8281036040938401526002815261060f60f31b6020820152919091019392505050565b6000602082840312156111cb57600080fd5b815167ffffffffffffffff808211156111e357600080fd5b818401915084601f8301126111f757600080fd5b81518181111561120957611209610d84565b61121c601f8201601f1916602001610dc3565b915080825285602082850101111561123357600080fd5b611244816020840160208601611048565b50949350505050565b60018060a01b038516815263ffffffff8416602082015282604082015260806060820152600061128060808301846110e1565b9695505050505050565b60008160001904831182151516156112a4576112a4611019565b500290565b8082018082111561076757610767611019565b6000602082840312156112ce57600080fd5b815161076481610df4565b634e487b7160e01b600052600160045260246000fd5b6001600160a01b038416815263ffffffff8316602082015260606040820181905260009061131f908301846110e1565b9594505050505056feed2630950398e2a792098014fdcfd8d9817be362c12f8684d7b7f9c1f2dd36c4a2646970667358221220e1afd3f7a04a00b92c99dfeb3652f8725c3851db66a3adf560610a6e923d2c7864736f6c63430008100033",
  "deployedBytecode": "0x60806040526004361061003f5760003560e01c806307cbd36c14610044578063172cedd614610066578063af5bcdac14610086578063e4fc6b6d146100a6575b600080fd5b34801561005057600080fd5b5061006461005f366004610ecc565b6100ae565b005b34801561007257600080fd5b50610064610081366004610f09565b6100e5565b34801561009257600080fd5b506100646100a1366004610f59565b61013a565b6100646101c7565b7f84882401b15b07d66e021ce83aef83bb1d37009af2fea3a7c3ed872472642fed6100d881610248565b6100e182610255565b5050565b6000805160206113298339815191525460ff161561011e5760405162461bcd60e51b815260040161011590610fbb565b60405180910390fd5b61013063e4fc6b6d60e01b6001610368565b6100e182826103de565b6000805160206113298339815191525460ff161561016a5760405162461bcd60e51b815260040161011590610fbb565b61017c63e4fc6b6d60e01b6001610368565b61018e6301f2f4db60e21b6001610368565b6101b87f84882401b15b07d66e021ce83aef83bb1d37009af2fea3a7c3ed872472642fed8461040a565b6101c282826103de565b505050565b6000341161023d5760405162461bcd60e51b815260206004820152603760248201527f49444142656e656669636961727946616365743a206d73672e76616c7565207360448201527f686f756c642062652067726561746572207468616e20300000000000000000006064820152608401610115565b6102463461047e565b565b610252813361054a565b50565b60008051602061132983398151915260005b82518110156101c25782818151811061028257610282611003565b6020026020010151600001516001600160a01b03167fa28017dec7757734b2d9df357f162beb25e6b604314dde5986a698a7cda3423d8483815181106102ca576102ca611003565b6020026020010151602001516040516102f291906001600160801b0391909116815260200190565b60405180910390a2610355600084838151811061031157610311611003565b60200260200101516000015185848151811061032f5761032f611003565b6020908102919091018101510151855461010090046001600160a01b03169291906105ac565b50806103608161102f565b915050610267565b6001600160e01b031980831690036103935760405163b0a19dd560e01b815260040160405180910390fd5b6001600160e01b03199190911660009081527ffc606c433378e3a7e0a6a531deac289b66caa1b4aa8554fd4ab2c6f1570f92d860205260409020805460ff1916911515919091179055565b600080516020611329833981519152805460ff19166001178155610401836106d8565b6101c282610255565b60008281527fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c62281160205260409020610441908261074f565b5060405133906001600160a01b0383169084907f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d90600090a45050565b604051818152600080516020611329833981519152907fddc9c30275a04c48091f24199f9c405765de34d979d6847f5b9798a57232d2e59060200160405180910390a18060000160019054906101000a90046001600160a01b03166001600160a01b031663cf81464b836040518263ffffffff1660e01b81526004016000604051808303818588803b15801561051357600080fd5b505af1158015610527573d6000803e3d6000fd5b505083546101c2935061010090046001600160a01b03169150600090508461076d565b6105548282610896565b6100e15761056a816001600160a01b03166108ef565b610575836020610901565b60405160200161058692919061106c565b60408051601f198184030181529082905262461bcd60e51b82526101159160040161110d565b60008060006105ba87610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663232d2b588b8b8b8b600067ffffffffffffffff8111156105fb576105fb610d84565b6040519080825280601f01601f191660200182016040528015610625576020820181803683370190505b5060405160240161063a959493929190611120565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261068393925090600401611172565b6000604051808303816000875af11580156106a2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106ca91908101906111b9565b506001979650505050505050565b604051600080516020611329833981519152906001600160a01b038316907fa07c91c183e42229e705a9795a1c06d76528b673788b849597364528c96eefb790600090a28054610100600160a81b0319166101006001600160a01b038481168202929092178084556101c292919004166000610c1b565b6000610764836001600160a01b038416610d41565b90505b92915050565b600080600061077b86610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663b96731c28a8a8a600067ffffffffffffffff8111156107bb576107bb610d84565b6040519080825280601f01601f1916602001820160405280156107e5576020820181803683370190505b506040516024016107f9949392919061124d565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b031916825261084293925090600401611172565b6000604051808303816000875af1158015610861573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261088991908101906111b9565b5060019695505050505050565b6000610764827fd3889cc5458b268d0544e5534672df1296288ca3f93cbd39bd6f497a5c622811600086815260209190915260409020906001600160a01b03811660009081526001830160205260408120541515610764565b60606107676001600160a01b03831660145b6060600061091083600261128a565b61091b9060026112a9565b67ffffffffffffffff81111561093357610933610d84565b6040519080825280601f01601f19166020018201604052801561095d576020820181803683370190505b509050600360fc1b8160008151811061097857610978611003565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106109a7576109a7611003565b60200101906001600160f81b031916908160001a905350600160028402015b6001811115610a34576f181899199a1a9b1b9c1cb0b131b232b360811b85600f16601081106109f7576109f7611003565b1a60f81b828281518110610a0d57610a0d611003565b60200101906001600160f81b031916908160001a90535060049490941c93600019016109c6565b5083156107645760405163c913478560e01b815260040160405180910390fd5b7f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837547fa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb546001600160a01b038116610bea576001600160a01b038216610b1957826001600160a01b03166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa158015610af2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1691906112bc565b91505b604051635b69006f60e11b81527f8aedc3b5d4bf031e11a7e2940f7251c005698405d58e02e1c247fed3b1b3a67460048201526001600160a01b0383169063b6d200de90602401602060405180830381865afa158015610b7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba191906112bc565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb555b6001600160a01b038216610c0057610c006112d9565b6001600160a01b038116610c1657610c166112d9565b915091565b6000806000610c2985610a54565b91509150816001600160a01b03166339255d5b82836001600160a01b031663d787840a8989600067ffffffffffffffff811115610c6857610c68610d84565b6040519080825280601f01601f191660200182016040528015610c92576020820181803683370190505b50604051602401610ca5939291906112ef565b60408051808303601f1901815291815260208201805160e094851b6001600160e01b03909116179052519185901b6001600160e01b0319168252610cee93925090600401611172565b6000604051808303816000875af1158015610d0d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d3591908101906111b9565b50600195945050505050565b6000818152600183016020526040812054610767575081546001808201845560008481526020808220909301849055845493815293810190915260409092205590565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610dbd57610dbd610d84565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610dec57610dec610d84565b604052919050565b6001600160a01b038116811461025257600080fd5b600082601f830112610e1a57600080fd5b8135602067ffffffffffffffff821115610e3657610e36610d84565b610e44818360051b01610dc3565b82815260069290921b84018101918181019086841115610e6357600080fd5b8286015b84811015610ec15760408189031215610e805760008081fd5b610e88610d9a565b8135610e9381610df4565b8152818501356001600160801b0381168114610eaf5760008081fd5b81860152835291830191604001610e67565b509695505050505050565b600060208284031215610ede57600080fd5b813567ffffffffffffffff811115610ef557600080fd5b610f0184828501610e09565b949350505050565b60008060408385031215610f1c57600080fd5b8235610f2781610df4565b9150602083013567ffffffffffffffff811115610f4357600080fd5b610f4f85828601610e09565b9150509250929050565b600080600060608486031215610f6e57600080fd5b8335610f7981610df4565b92506020840135610f8981610df4565b9150604084013567ffffffffffffffff811115610fa557600080fd5b610fb186828701610e09565b9150509250925092565b60208082526028908201527f49444142656e656669636961727946616365743a20616c726561647920696e696040820152671d1a585b1a5e995960c21b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001820161104157611041611019565b5060010190565b60005b8381101561106357818101518382015260200161104b565b50506000910152565b7f416363657373436f6e74726f6c3a206163636f756e74200000000000000000008152600083516110a4816017850160208801611048565b7001034b99036b4b9b9b4b733903937b6329607d1b60179184019182015283516110d5816028840160208801611048565b01602801949350505050565b600081518084526110f9816020860160208601611048565b601f01601f19169290920160200192915050565b60208152600061076460208301846110e1565b6001600160a01b03868116825263ffffffff86166020830152841660408201526001600160801b038316606082015260a060808201819052600090611167908301846110e1565b979650505050505050565b6001600160a01b0383168152606060208201819052600090611196908301846110e1565b8281036040938401526002815261060f60f31b6020820152919091019392505050565b6000602082840312156111cb57600080fd5b815167ffffffffffffffff808211156111e357600080fd5b818401915084601f8301126111f757600080fd5b81518181111561120957611209610d84565b61121c601f8201601f1916602001610dc3565b915080825285602082850101111561123357600080fd5b611244816020840160208601611048565b50949350505050565b60018060a01b038516815263ffffffff8416602082015282604082015260806060820152600061128060808301846110e1565b9695505050505050565b60008160001904831182151516156112a4576112a4611019565b500290565b8082018082111561076757610767611019565b6000602082840312156112ce57600080fd5b815161076481610df4565b634e487b7160e01b600052600160045260246000fd5b6001600160a01b038416815263ffffffff8316602082015260606040820181905260009061131f908301846110e1565b9594505050505056feed2630950398e2a792098014fdcfd8d9817be362c12f8684d7b7f9c1f2dd36c4a2646970667358221220e1afd3f7a04a00b92c99dfeb3652f8725c3851db66a3adf560610a6e923d2c7864736f6c63430008100033",
  "devdoc": {
    "details": "Beneficiary implemented using a Superfluid IDA index",
    "kind": "dev",
    "methods": {},
    "title": "IDABeneficiaryFacet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "distribute()": {
        "notice": "Distribute to beneficiaries"
      },
      "initializeIDABeneficiary(address,(address,uint128)[])": {
        "notice": "Initialize beneficiary"
      },
      "initializeIDABeneficiary(address,address,(address,uint128)[])": {
        "notice": "Initialize beneficiary"
      },
      "updateBeneficiaryUnits((address,uint128)[])": {
        "notice": "Update beneficiaries"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
