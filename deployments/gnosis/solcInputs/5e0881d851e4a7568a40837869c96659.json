{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\n\ninterface IOwnable is IERC173 {}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnable } from './IOwnable.sol';\n\ninterface ISafeOwnable is IOwnable {\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function nomineeOwner() external view returns (address);\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnableInternal } from './IOwnableInternal.sol';\n\ninterface ISafeOwnableInternal is IOwnableInternal {\n    error SafeOwnable__NotNomineeOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { IOwnable } from './IOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IOwnable, OwnableInternal {\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual returns (address) {\n        return _owner();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account) public virtual onlyOwner {\n        _transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address owner) {\n        owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        _setOwner(account);\n    }\n\n    function _setOwner(address account) internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, account);\n        l.owner = account;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Ownable } from './Ownable.sol';\nimport { ISafeOwnable } from './ISafeOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function nomineeOwner() public view virtual returns (address) {\n        return _nomineeOwner();\n    }\n\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        _acceptOwnership();\n    }\n\n    function _transferOwnership(\n        address account\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\n        super._transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\n    modifier onlyNomineeOwner() {\n        if (msg.sender != _nomineeOwner())\n            revert SafeOwnable__NotNomineeOwner();\n        _;\n    }\n\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function _nomineeOwner() internal view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function _acceptOwnership() internal virtual {\n        _setOwner(msg.sender);\n        delete SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice set nominee owner, granting permission to call acceptOwnership\n     */\n    function _transferOwnership(address account) internal virtual override {\n        SafeOwnableStorage.layout().nomineeOwner = account;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Map implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableMap {\n    error EnumerableMap__IndexOutOfBounds();\n    error EnumerableMap__NonExistentKey();\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct AddressToAddressMap {\n        Map _inner;\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function at(\n        AddressToAddressMap storage map,\n        uint256 index\n    ) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n\n        return (\n            address(uint160(uint256(key))),\n            address(uint160(uint256(value)))\n        );\n    }\n\n    function at(\n        UintToAddressMap storage map,\n        uint256 index\n    ) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function contains(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function contains(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(\n        AddressToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function length(\n        UintToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function get(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\n                )\n            );\n    }\n\n    function get(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function set(\n        AddressToAddressMap storage map,\n        address key,\n        address value\n    ) internal returns (bool) {\n        return\n            _set(\n                map._inner,\n                bytes32(uint256(uint160(key))),\n                bytes32(uint256(uint160(value)))\n            );\n    }\n\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        AddressToAddressMap storage map,\n        address key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function remove(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function toArray(\n        AddressToAddressMap storage map\n    )\n        internal\n        view\n        returns (address[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function toArray(\n        UintToAddressMap storage map\n    )\n        internal\n        view\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function keys(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n            }\n        }\n    }\n\n    function keys(\n        UintToAddressMap storage map\n    ) internal view returns (uint256[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n            }\n        }\n    }\n\n    function values(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function values(\n        UintToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function _at(\n        Map storage map,\n        uint256 index\n    ) private view returns (bytes32, bytes32) {\n        if (index >= map._entries.length)\n            revert EnumerableMap__IndexOutOfBounds();\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _contains(\n        Map storage map,\n        bytes32 key\n    ) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\n        unchecked {\n            return map._entries[keyIndex - 1]._value;\n        }\n    }\n\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            unchecked {\n                map._entries[keyIndex - 1]._value = value;\n            }\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            unchecked {\n                MapEntry storage last = map._entries[map._entries.length - 1];\n\n                // move last entry to now-vacant index\n                map._entries[keyIndex - 1] = last;\n                map._indexes[last._key] = keyIndex;\n            }\n\n            // clear last index\n            map._entries.pop();\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Proxy } from '../../Proxy.sol';\nimport { IDiamondBase } from './IDiamondBase.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is IDiamondBase, Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        implementation = address(bytes20(l.facets[msg.sig]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IProxy } from '../../IProxy.sol';\n\ninterface IDiamondBase is IProxy {}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { DiamondBase } from '../base/DiamondBase.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondFallback } from './IDiamondFallback.sol';\n\n// TODO: DiamondFallback interface\n\n/**\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\n */\nabstract contract DiamondFallback is\n    IDiamondFallback,\n    OwnableInternal,\n    DiamondBase\n{\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = _getFallbackAddress();\n    }\n\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\n        _setFallbackAddress(fallbackAddress);\n    }\n\n    /**\n     * @inheritdoc DiamondBase\n     * @notice query custom fallback address is no implementation is found\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        implementation = super._getImplementation();\n\n        if (implementation == address(0)) {\n            implementation = _getFallbackAddress();\n        }\n    }\n\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function _getFallbackAddress()\n        internal\n        view\n        virtual\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondBase } from '../base/IDiamondBase.sol';\n\ninterface IDiamondFallback is IDiamondBase {\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress);\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function setFallbackAddress(address fallbackAddress) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\nimport { IERC165 } from '../../interfaces/IERC165.sol';\nimport { IDiamondBase } from './base/IDiamondBase.sol';\nimport { IDiamondFallback } from './fallback/IDiamondFallback.sol';\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\n\ninterface ISolidStateDiamond is\n    IDiamondBase,\n    IDiamondFallback,\n    IDiamondReadable,\n    IDiamondWritable,\n    ISafeOwnable,\n    IERC165\n{\n    receive() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondReadable } from './IDiamondReadable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondReadable is IDiamondReadable {\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facets() external view returns (Facet[] memory diamondFacets) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet) {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondReadable {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { IDiamondWritable } from './IDiamondWritable.sol';\nimport { DiamondWritableInternal } from './DiamondWritableInternal.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondWritable is\n    IDiamondWritable,\n    DiamondWritableInternal,\n    OwnableInternal\n{\n    /**\n     * @inheritdoc IDiamondWritable\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external onlyOwner {\n        _diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\n    using AddressUtils for address;\n\n    bytes32 private constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 private constant CLEAR_SELECTOR_MASK =\n        bytes32(uint256(0xffffffff << 224));\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function _diamondCut(\n        FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                FacetCut memory facetCut = facetCuts[i];\n                FacetCutAction action = facetCut.action;\n\n                if (facetCut.selectors.length == 0)\n                    revert DiamondWritable__SelectorNotSpecified();\n\n                if (action == FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = _addFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == FacetCutAction.REPLACE) {\n                    _replaceFacetSelectors(l, facetCut);\n                } else if (action == FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = _removeFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            _initialize(target, data);\n        }\n    }\n\n    function _addFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (\n                facetCut.target != address(this) &&\n                !facetCut.target.isContract()\n            ) revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) != address(0))\n                    revert DiamondWritable__SelectorAlreadyAdded();\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _removeFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (facetCut.target != address(0))\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n\n                if (address(bytes20(oldFacet)) == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _replaceFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            if (!facetCut.target.isContract())\n                revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                if (oldFacetAddress == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n                if (oldFacetAddress == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n                if (oldFacetAddress == facetCut.target)\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function _initialize(address target, bytes memory data) private {\n        if ((target == address(0)) != (data.length == 0))\n            revert DiamondWritable__InvalidInitializationParameters();\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                if (!target.isContract())\n                    revert DiamondWritable__TargetHasNoCode();\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondWritable is IDiamondWritableInternal {\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional target of initialization delegatecall\n     * @param data optional initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IDiamondWritableInternal {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    error DiamondWritable__InvalidInitializationParameters();\n    error DiamondWritable__RemoveTargetNotZeroAddress();\n    error DiamondWritable__ReplaceTargetIsIdentical();\n    error DiamondWritable__SelectorAlreadyAdded();\n    error DiamondWritable__SelectorIsImmutable();\n    error DiamondWritable__SelectorNotFound();\n    error DiamondWritable__SelectorNotSpecified();\n    error DiamondWritable__TargetHasNoCode();\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IProxy {\n    error Proxy__ImplementationIsNotContract();\n\n    fallback() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\nimport { IProxy } from './IProxy.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy is IProxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        if (!implementation.isContract())\n            revert Proxy__ImplementationIsNotContract();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { IERC1155Base } from './IERC1155Base.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from './ERC1155BaseInternal.sol';\n\n/**\n * @title Base ERC1155 contract\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155Base is IERC1155Base, ERC1155BaseInternal {\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) public view virtual returns (uint256) {\n        return _balanceOf(account, id);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual returns (uint256[] memory) {\n        if (accounts.length != ids.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        unchecked {\n            for (uint256 i; i < accounts.length; i++) {\n                if (accounts[i] == address(0))\n                    revert ERC1155Base__BalanceQueryZeroAddress();\n                batchBalances[i] = balances[ids[i]][accounts[i]];\n            }\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view virtual returns (bool) {\n        return ERC1155BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function setApprovalForAll(address operator, bool status) public virtual {\n        if (msg.sender == operator) revert ERC1155Base__SelfApproval();\n        ERC1155BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransfer(msg.sender, from, to, id, amount, data);\n    }\n\n    /**\n     * @inheritdoc IERC1155\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender))\n            revert ERC1155Base__NotOwnerOrApproved();\n        _safeTransferBatch(msg.sender, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Receiver } from '../../../interfaces/IERC1155Receiver.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\nimport { ERC1155BaseStorage } from './ERC1155BaseStorage.sol';\n\n/**\n * @title Base ERC1155 internal functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nabstract contract ERC1155BaseInternal is IERC1155BaseInternal {\n    using AddressUtils for address;\n\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account,\n        uint256 id\n    ) internal view virtual returns (uint256) {\n        if (account == address(0))\n            revert ERC1155Base__BalanceQueryZeroAddress();\n        return ERC1155BaseStorage.layout().balances[id][account];\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        ERC1155BaseStorage.layout().balances[id][account] += amount;\n\n        emit TransferSingle(msg.sender, address(0), account, id, amount);\n    }\n\n    /**\n     * @notice mint given quantity of tokens for given address\n     * @param account beneficiary of minting\n     * @param id token ID\n     * @param amount quantity of tokens to mint\n     * @param data data payload\n     */\n    function _safeMint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _mint(account, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @dev ERC1155Receiver implementation is not checked\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _mintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__MintToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            balances[ids[i]][account] += amounts[i];\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), account, ids, amounts);\n    }\n\n    /**\n     * @notice mint batch of tokens for given address\n     * @param account beneficiary of minting\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to mint\n     * @param data data payload\n     */\n    function _safeMintBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _mintBatch(account, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            account,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice burn given quantity of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param id token ID\n     * @param amount quantity of tokens to burn\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(\n            msg.sender,\n            account,\n            address(0),\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            ''\n        );\n\n        mapping(address => uint256) storage balances = ERC1155BaseStorage\n            .layout()\n            .balances[id];\n\n        unchecked {\n            if (amount > balances[account])\n                revert ERC1155Base__BurnExceedsBalance();\n            balances[account] -= amount;\n        }\n\n        emit TransferSingle(msg.sender, account, address(0), id, amount);\n    }\n\n    /**\n     * @notice burn given batch of tokens held by given address\n     * @param account holder of tokens to burn\n     * @param ids token IDs\n     * @param amounts quantities of tokens to burn\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        if (account == address(0)) revert ERC1155Base__BurnFromZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(msg.sender, account, address(0), ids, amounts, '');\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            for (uint256 i; i < ids.length; i++) {\n                uint256 id = ids[i];\n                if (amounts[i] > balances[id][account])\n                    revert ERC1155Base__BurnExceedsBalance();\n                balances[id][account] -= amounts[i];\n            }\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _transfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(\n            operator,\n            sender,\n            recipient,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        unchecked {\n            uint256 senderBalance = balances[id][sender];\n            if (amount > senderBalance)\n                revert ERC1155Base__TransferExceedsBalance();\n            balances[id][sender] = senderBalance - amount;\n        }\n\n        balances[id][recipient] += amount;\n\n        emit TransferSingle(operator, sender, recipient, id, amount);\n    }\n\n    /**\n     * @notice transfer tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransfer(\n        address operator,\n        address sender,\n        address recipient,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        _transfer(operator, sender, recipient, id, amount, data);\n\n        _doSafeTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            id,\n            amount,\n            data\n        );\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @dev ERC1155Receiver implementation is not checked\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _transferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        if (recipient == address(0))\n            revert ERC1155Base__TransferToZeroAddress();\n        if (ids.length != amounts.length)\n            revert ERC1155Base__ArrayLengthMismatch();\n\n        _beforeTokenTransfer(operator, sender, recipient, ids, amounts, data);\n\n        mapping(uint256 => mapping(address => uint256))\n            storage balances = ERC1155BaseStorage.layout().balances;\n\n        for (uint256 i; i < ids.length; ) {\n            uint256 token = ids[i];\n            uint256 amount = amounts[i];\n\n            unchecked {\n                uint256 senderBalance = balances[token][sender];\n\n                if (amount > senderBalance)\n                    revert ERC1155Base__TransferExceedsBalance();\n\n                balances[token][sender] = senderBalance - amount;\n\n                i++;\n            }\n\n            // balance increase cannot be unchecked because ERC1155Base neither tracks nor validates a totalSupply\n            balances[token][recipient] += amount;\n        }\n\n        emit TransferBatch(operator, sender, recipient, ids, amounts);\n    }\n\n    /**\n     * @notice transfer batch of tokens between given addresses\n     * @param operator executor of transfer\n     * @param sender sender of tokens\n     * @param recipient receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _safeTransferBatch(\n        address operator,\n        address sender,\n        address recipient,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        _transferBatch(operator, sender, recipient, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            operator,\n            sender,\n            recipient,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**\n     * @notice wrap given element in array of length 1\n     * @param element element to wrap\n     * @return singleton array\n     */\n    function _asSingletonArray(\n        uint256 element\n    ) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector)\n                    revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice revert if applicable transfer recipient is not valid ERC1155Receiver\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\n                ) revert ERC1155Base__ERC1155ReceiverRejected();\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert ERC1155Base__ERC1155ReceiverNotImplemented();\n            }\n        }\n    }\n\n    /**\n     * @notice ERC1155 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @dev called for both single and batch transfers\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids token IDs\n     * @param amounts quantities of tokens to transfer\n     * @param data data payload\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/ERC1155BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC1155BaseStorage {\n    struct Layout {\n        mapping(uint256 => mapping(address => uint256)) balances;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155 } from '../../../interfaces/IERC1155.sol';\nimport { IERC1155BaseInternal } from './IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155Base is IERC1155BaseInternal, IERC1155 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/base/IERC1155BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Internal } from '../../../interfaces/IERC1155Internal.sol';\n\n/**\n * @title ERC1155 base interface\n */\ninterface IERC1155BaseInternal is IERC1155Internal {\n    error ERC1155Base__ArrayLengthMismatch();\n    error ERC1155Base__BalanceQueryZeroAddress();\n    error ERC1155Base__NotOwnerOrApproved();\n    error ERC1155Base__SelfApproval();\n    error ERC1155Base__BurnExceedsBalance();\n    error ERC1155Base__BurnFromZeroAddress();\n    error ERC1155Base__ERC1155ReceiverRejected();\n    error ERC1155Base__ERC1155ReceiverNotImplemented();\n    error ERC1155Base__MintToZeroAddress();\n    error ERC1155Base__TransferExceedsBalance();\n    error ERC1155Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal } from '../base/ERC1155BaseInternal.sol';\nimport { IERC1155Enumerable } from './IERC1155Enumerable.sol';\nimport { ERC1155EnumerableInternal, ERC1155EnumerableStorage } from './ERC1155EnumerableInternal.sol';\n\n/**\n * @title ERC1155 implementation including enumerable and aggregate functions\n */\nabstract contract ERC1155Enumerable is\n    IERC1155Enumerable,\n    ERC1155EnumerableInternal\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function totalHolders(uint256 id) public view virtual returns (uint256) {\n        return _totalHolders(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function accountsByToken(\n        uint256 id\n    ) public view virtual returns (address[] memory) {\n        return _accountsByToken(id);\n    }\n\n    /**\n     * @inheritdoc IERC1155Enumerable\n     */\n    function tokensByAccount(\n        address account\n    ) public view virtual returns (uint256[] memory) {\n        return _tokensByAccount(account);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC1155BaseInternal, ERC1155BaseStorage } from '../base/ERC1155BaseInternal.sol';\nimport { ERC1155EnumerableStorage } from './ERC1155EnumerableStorage.sol';\n\n/**\n * @title ERC1155Enumerable internal functions\n */\nabstract contract ERC1155EnumerableInternal is ERC1155BaseInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function _totalSupply(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().totalSupply[id];\n    }\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function _totalHolders(uint256 id) internal view virtual returns (uint256) {\n        return ERC1155EnumerableStorage.layout().accountsByToken[id].length();\n    }\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function _accountsByToken(\n        uint256 id\n    ) internal view virtual returns (address[] memory) {\n        EnumerableSet.AddressSet storage accounts = ERC1155EnumerableStorage\n            .layout()\n            .accountsByToken[id];\n\n        address[] memory addresses = new address[](accounts.length());\n\n        unchecked {\n            for (uint256 i; i < accounts.length(); i++) {\n                addresses[i] = accounts.at(i);\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function _tokensByAccount(\n        address account\n    ) internal view virtual returns (uint256[] memory) {\n        EnumerableSet.UintSet storage tokens = ERC1155EnumerableStorage\n            .layout()\n            .tokensByAccount[account];\n\n        uint256[] memory ids = new uint256[](tokens.length());\n\n        unchecked {\n            for (uint256 i; i < tokens.length(); i++) {\n                ids[i] = tokens.at(i);\n            }\n        }\n\n        return ids;\n    }\n\n    /**\n     * @notice ERC1155 hook: update aggregate values\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from != to) {\n            ERC1155EnumerableStorage.Layout storage l = ERC1155EnumerableStorage\n                .layout();\n            mapping(uint256 => EnumerableSet.AddressSet)\n                storage tokenAccounts = l.accountsByToken;\n            EnumerableSet.UintSet storage fromTokens = l.tokensByAccount[from];\n            EnumerableSet.UintSet storage toTokens = l.tokensByAccount[to];\n\n            for (uint256 i; i < ids.length; ) {\n                uint256 amount = amounts[i];\n\n                if (amount > 0) {\n                    uint256 id = ids[i];\n\n                    if (from == address(0)) {\n                        l.totalSupply[id] += amount;\n                    } else if (_balanceOf(from, id) == amount) {\n                        tokenAccounts[id].remove(from);\n                        fromTokens.remove(id);\n                    }\n\n                    if (to == address(0)) {\n                        l.totalSupply[id] -= amount;\n                    } else if (_balanceOf(to, id) == 0) {\n                        tokenAccounts[id].add(to);\n                        toTokens.add(id);\n                    }\n                }\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 => uint256) totalSupply;\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/enumerable/IERC1155Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155BaseInternal } from '../base/IERC1155BaseInternal.sol';\n\n/**\n * @title ERC1155 enumerable and aggregate function interface\n */\ninterface IERC1155Enumerable is IERC1155BaseInternal {\n    /**\n     * @notice query total minted supply of given token\n     * @param id token id to query\n     * @return token supply\n     */\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query total number of holders for given token\n     * @param id token id to query\n     * @return quantity of holders\n     */\n    function totalHolders(uint256 id) external view returns (uint256);\n\n    /**\n     * @notice query holders of given token\n     * @param id token id to query\n     * @return list of holder addresses\n     */\n    function accountsByToken(\n        uint256 id\n    ) external view returns (address[] memory);\n\n    /**\n     * @notice query tokens held by given address\n     * @param account address to query\n     * @return list of token ids\n     */\n    function tokensByAccount(\n        address account\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/ISolidStateERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155Base } from './base/IERC1155Base.sol';\nimport { IERC1155Enumerable } from './enumerable/IERC1155Enumerable.sol';\nimport { IERC1155Metadata } from './metadata/IERC1155Metadata.sol';\n\ninterface ISolidStateERC1155 is\n    IERC1155Base,\n    IERC1155Enumerable,\n    IERC1155Metadata\n{}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { IERC1155Metadata } from './IERC1155Metadata.sol';\nimport { ERC1155MetadataInternal } from './ERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155 metadata extensions\n */\nabstract contract ERC1155Metadata is IERC1155Metadata, ERC1155MetadataInternal {\n    using UintUtils for uint256;\n\n    /**\n     * @notice inheritdoc IERC1155Metadata\n     */\n    function uri(uint256 tokenId) public view virtual returns (string memory) {\n        ERC1155MetadataStorage.Layout storage l = ERC1155MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\n\n/**\n * @title ERC1155Metadata internal functions\n */\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\n    /**\n     * @notice set base metadata URI\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\n     * @param baseURI base URI\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\n    }\n\n    /**\n     * @notice set per-token metadata URI\n     * @param tokenId token whose metadata URI to set\n     * @param tokenURI per-token URI\n     */\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\n        emit URI(tokenURI, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/SolidStateERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\nimport { ERC1155Base, ERC1155BaseInternal } from './base/ERC1155Base.sol';\nimport { ERC1155Enumerable } from './enumerable/ERC1155Enumerable.sol';\nimport { ERC1155EnumerableInternal } from './enumerable/ERC1155EnumerableInternal.sol';\nimport { ERC1155Metadata } from './metadata/ERC1155Metadata.sol';\nimport { ISolidStateERC1155 } from './ISolidStateERC1155.sol';\n\n/**\n * @title SolidState ERC1155 implementation\n */\nabstract contract SolidStateERC1155 is\n    ISolidStateERC1155,\n    ERC1155Base,\n    ERC1155Enumerable,\n    ERC1155Metadata,\n    ERC165Base\n{\n    /**\n     * @inheritdoc ERC1155BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n        override(ERC1155BaseInternal, ERC1155EnumerableInternal)\n    {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721Base } from './IERC721Base.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\n\n/**\n * @title Base ERC721 implementation, excluding optional extensions\n */\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view returns (bool) {\n        return _isApprovedForAll(account, operator);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address operator, uint256 tokenId) public payable {\n        _handleApproveMessageValue(operator, tokenId, msg.value);\n        address owner = ownerOf(tokenId);\n        if (operator == owner) revert ERC721Base__SelfApproval();\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender))\n            revert ERC721Base__NotOwnerOrApproved();\n        _approve(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool status) public {\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\n\n/**\n * @title Base ERC721 internal functions\n */\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\n        return ERC721BaseStorage.layout().holderTokens[account].length();\n    }\n\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\n    }\n\n    function _getApproved(\n        uint256 tokenId\n    ) internal view virtual returns (address) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(\n        address account,\n        address operator\n    ) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        address owner = _ownerOf(tokenId);\n\n        return (spender == owner ||\n            _getApproved(tokenId) == spender ||\n            _isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        _approve(address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n        l.holderTokens[owner].remove(tokenId);\n        l.tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        if (_ownerOf(tokenId) != from) revert ERC721Base__NotTokenOwner();\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _approve(address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n        l.holderTokens[from].remove(tokenId);\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _approve(address operator, uint256 tokenId) internal virtual {\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\n        emit Approval(_ownerOf(tokenId), operator, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes memory returnData = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                msg.sender,\n                from,\n                tokenId,\n                data\n            ),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\n        return returnValue == type(IERC721Receiver).interfaceId;\n    }\n\n    /**\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\n     * @param operator beneficiary of approval\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC721BaseStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Base');\n\n    struct Layout {\n        EnumerableMap.UintToAddressMap tokenOwners;\n        mapping(address => EnumerableSet.UintSet) holderTokens;\n        mapping(uint256 => address) tokenApprovals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\n\nabstract contract ERC721Enumerable is\n    IERC721Enumerable,\n    ERC721EnumerableInternal\n{\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) public view returns (uint256) {\n        return _tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        return _tokenByIndex(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\n\nabstract contract ERC721EnumerableInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice TODO\n     */\n    function _totalSupply() internal view returns (uint256) {\n        return ERC721BaseStorage.layout().tokenOwners.length();\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) internal view returns (uint256) {\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenByIndex(\n        uint256 index\n    ) internal view returns (uint256 tokenId) {\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/ISolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Base } from './base/IERC721Base.sol';\nimport { IERC721Enumerable } from './enumerable/IERC721Enumerable.sol';\nimport { IERC721Metadata } from './metadata/IERC721Metadata.sol';\n\ninterface ISolidStateERC721 is IERC721Base, IERC721Enumerable, IERC721Metadata {\n    error SolidStateERC721__PayableApproveNotSupported();\n    error SolidStateERC721__PayableTransferNotSupported();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\nimport { IERC721Metadata } from './IERC721Metadata.sol';\n\n/**\n * @title ERC721 metadata extensions\n */\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function name() external view virtual returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function symbol() external view virtual returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) external view virtual returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    /**\n     * @inheritdoc ERC721MetadataInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata internal functions\n */\nabstract contract ERC721MetadataInternal is\n    IERC721MetadataInternal,\n    ERC721BaseInternal\n{\n    using UintUtils for uint256;\n\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view virtual returns (string memory) {\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice ERC721 hook: clear per-token URI data on burn\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (to == address(0)) {\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/SolidStateERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC165Base } from '../../introspection/ERC165/base/ERC165Base.sol';\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\nimport { ISolidStateERC721 } from './ISolidStateERC721.sol';\n\n/**\n * @title SolidState ERC721 implementation, including recommended extensions\n */\nabstract contract SolidStateERC721 is\n    ISolidStateERC721,\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base\n{\n    /**\n     * @notice ERC721 hook: revert if value is included in external approve function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableApproveNotSupported();\n        super._handleApproveMessageValue(operator, tokenId, value);\n    }\n\n    /**\n     * @notice ERC721 hook: revert if value is included in external transfer function call\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual override {\n        if (value > 0) revert SolidStateERC721__PayableTransferNotSupported();\n        super._handleTransferMessageValue(from, to, tokenId, value);\n    }\n\n    /**\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.0;\n\nimport {\n    ISuperfluid,\n    ISuperToken\n} from \"../interfaces/superfluid/ISuperfluid.sol\";\n\nimport {\n    IConstantFlowAgreementV1\n} from \"../interfaces/agreements/IConstantFlowAgreementV1.sol\";\n\nimport {\n    IInstantDistributionAgreementV1\n} from \"../interfaces/agreements/IInstantDistributionAgreementV1.sol\";\n\n/**\n * @title Library for Token Centric Interface\n * @author Superfluid\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\n * of ISuperToken\n */\nlibrary SuperTokenV1Library {\n\n    /** CFA BASE CRUD ************************************* */\n\n    /**\n     * @dev Create flow without userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Create flow with userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The userdata passed along with call\n     */\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            userData // userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Update flow without userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Update flow with userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The userdata passed along with call\n     */\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Delete flow without userData\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     */\n    function deleteFlow(ISuperToken token, address sender, address receiver)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (token, sender, receiver, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Delete flow with userData\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param userData The userdata passed along with call\n     */\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (token, sender, receiver, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /** CFA ACL ************************************* */\n\n    /**\n     * @dev Update permissions for flow operator\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param allowCreate creation permissions\n     * @param allowCreate update permissions\n     * @param allowCreate deletion permissions\n     * @param flowRateAllowance The allowance provided to flowOperator\n     */\n    function setFlowPermissions(\n        ISuperToken token,\n        address flowOperator,\n        bool allowCreate,\n        bool allowUpdate,\n        bool allowDelete,\n        int96 flowRateAllowance\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\n            | (allowUpdate ? 1 : 0) << 1\n            | (allowDelete ? 1 : 0) << 2;\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowOperatorPermissions,\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator - give operator max permissions\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     */\n    function setMaxFlowPermissions(\n        ISuperToken token,\n        address flowOperator\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.authorizeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator - revoke all permission\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     */\n    function revokeFlowPermissions(\n        ISuperToken token,\n        address flowOperator\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.revokeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator in callback\n     * @notice allowing userData to be a parameter here triggered stack to deep error\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param allowCreate creation permissions\n     * @param allowCreate update permissions\n     * @param allowCreate deletion permissions\n     * @param flowRateAllowance The allowance provided to flowOperator\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function setFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bool allowCreate,\n        bool allowUpdate,\n        bool allowDelete,\n        int96 flowRateAllowance,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\n            | (allowUpdate ? 1 : 0) << 1\n            | (allowDelete ? 1 : 0) << 2;\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowOperatorPermissions,\n                (\n                    token,\n                    flowOperator,\n                    permissionsBitmask,\n                    flowRateAllowance,\n                    new bytes(0)\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update permissions for flow operator - give operator max permissions\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function setMaxFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.authorizeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n    * @dev Update permissions for flow operator - revoke all permission\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function revokeFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.revokeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n\n    /**\n     * @dev Creates flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Updates flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n     /**\n     * @dev Deletes flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     */\n    function deleteFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (token, sender, receiver, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param userData The user provided data\n     */\n    function deleteFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (token, sender, receiver, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n\n    /** CFA With CTX FUNCTIONS ************************************* */\n\n    /**\n     * @dev Create flow with context and userData\n     * @param token The token to flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function createFlowWithCtx(\n        ISuperToken token,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Create flow by operator with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function createFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update flow with context\n     * @param token The token to flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowWithCtx(\n        ISuperToken token,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update flow by operator with context\n     * @param token The token to flow\n     * @param sender The receiver of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Delete flow with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function deleteFlowWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Delete flow by operator with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function deleteFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /** CFA VIEW FUNCTIONS ************************************* */\n\n    /**\n     * @dev get flow rate between two accounts for given token\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @return flowRate The flow rate\n     */\n    function getFlowRate(ISuperToken token, address sender, address receiver)\n        internal view returns(int96 flowRate)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\n    }\n\n    /**\n     * @dev get flow info between two accounts for given token\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\n     * @return flowRate The flow rate\n     * @return deposit The amount of deposit the flow\n     * @return owedDeposit The amount of owed deposit of the flow\n     */\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\n        internal view\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\n    }\n\n    /**\n     * @dev get net flow rate for given account for given token\n     * @param token Super token address\n     * @param account Account to query\n     * @return flowRate The net flow rate of the account\n     */\n    function getNetFlowRate(ISuperToken token, address account)\n        internal view returns (int96 flowRate)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getNetFlow(token, account);\n    }\n\n    /**\n     * @dev get the aggregated flow info of the account\n     * @param token Super token address\n     * @param account Account to query\n     * @return lastUpdated Timestamp of the last change of the net flow\n     * @return flowRate The net flow rate of token for account\n     * @return deposit The sum of all deposits for account's flows\n     * @return owedDeposit The sum of all owed deposits for account's flows\n     */\n    function getNetFlowInfo(ISuperToken token, address account)\n        internal view\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getAccountFlowInfo(token, account);\n    }\n\n    /**\n     * @dev calculate buffer for a flow rate\n     * @param token The token used in flow\n     * @param flowRate The flowrate to calculate the needed buffer for\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\n     */\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\n        returns (uint256 bufferAmount)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\n    }\n\n    /**\n     * @dev get existing flow permissions\n     * @param token The token used in flow\n     * @param sender sender of a flow\n     * @param flowOperator the address we are checking permissions of for sender & token\n     * @return allowCreate is true if the flowOperator can create flows\n     * @return allowUpdate is true if the flowOperator can update flows\n     * @return allowDelete is true if the flowOperator can delete flows\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\n     */\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\n        internal view\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        uint8 permissionsBitmask;\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\n        allowCreate = permissionsBitmask & 1 == 1 ? true : false;\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1 ? true : false;\n        allowDelete = permissionsBitmask >> 2 & 1 == 1 ? true : false;\n    }\n\n\n     /** IDA VIEW FUNCTIONS ************************************* */\n\n\n    /**\n     * @dev Gets an index by its ID and publisher.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @return exist True if the index exists.\n     * @return indexValue Total value of the index.\n     * @return totalUnitsApproved Units of the index approved by subscribers.\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\n     */\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\n        internal view\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getIndex(token, publisher, indexId);\n    }\n\n    /**\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param amount Amount of tokens desired to distribute.\n     * @return actualAmount Amount to be distributed with correct rounding.\n     * @return newIndexValue The index value after the distribution would be called.\n     */\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\n        internal view\n        returns (uint256 actualAmount, uint128 newIndexValue)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.calculateDistribution(token, publisher, indexId, amount);\n    }\n\n    /**\n     * @dev List all subscriptions of an address\n     * @param token Super token used in the indexes listed.\n     * @param subscriber Subscriber address.\n     * @return publishers Publishers of the indices.\n     * @return indexIds IDs of the indices.\n     * @return unitsList Units owned of the indices.\n     */\n    function listSubscriptions(\n        ISuperToken token,\n        address subscriber\n    )\n        internal view\n        returns (\n            address[] memory publishers,\n            uint32[] memory indexIds,\n            uint128[] memory unitsList\n        )\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.listSubscriptions(token, subscriber);\n    }\n\n    /**\n     * @dev Gets subscription by publisher, index id, and subscriber.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber to the index.\n     * @return exist True if the subscription exists.\n     * @return approved True if the subscription has been approved by the subscriber.\n     * @return units Units held by the subscriber\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\n     */\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\n        internal view\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getSubscription(token, publisher, indexId, subscriber);\n    }\n\n    /*\n     * @dev Gets subscription by the agreement ID.\n     * @param token Super Token used with the index.\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\n     * @return publisher Publisher of the index.\n     * @return indexId ID of the index.\n     * @return approved True if the subscription has been approved by the subscriber.\n     * @return units Units held by the subscriber\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\n     */\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\n        internal view\n        returns (\n            address publisher,\n            uint32 indexId,\n            bool approved,\n            uint128 units,\n            uint256 pendingDistribution\n        )\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getSubscriptionByID(token, agreementId);\n    }\n\n\n    /** IDA BASE FUNCTIONS ************************************* */\n\n\n    /**\n     * @dev Creates a new index.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     */\n    function createIndex(\n        ISuperToken token,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates a new index with userData.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function createIndex(\n        ISuperToken token,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates an index value. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     */\n    function updateIndexValue(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     * @param userData Arbitrary user data field.\n     */\n    function updateIndexValue(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\n     * passing the new total index value, you pass the amount of tokens desired to be distributed. \n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount - total number of tokens desired to be distributed \n     * NOTE in many cases, there can be some precision loss \n     This may cause a slight difference in the amount param specified and the actual amount distributed. \n     See below for math:\n     //indexDelta = amount the index will be updated by during an internal call to _updateIndex().\n     It is calculated like so:\n     indexDelta = amount / totalUnits \n     (see the distribute() implementatation in ./agreements/InstantDistributionAgreement.sol)\n     * NOTE Solidity does not support floating point numbers\n     So the indexDelta will be rounded down to the nearest integer. \n     This will create a 'remainder' amount of tokens that will not be distributed \n     (we'll call this the 'distribution modulo')\n     distributionModulo = amount - indexDelta * totalUnits\n     * NOTE due to rounding, there may be a small amount of tokens left in the publisher's account\n     This amount is equal to the 'distributionModulo' value\n     //\n     */\n    function distribute(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\n     * passing the new total index value, this function will increase the index value by `amount`.\n     * This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount Amount by which the index value should increase.\n     * @param userData Arbitrary user data field.\n     */\n    function distribute(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     */\n    function approveSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function approveSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     */\n    function revokeSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function revokeSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     */\n    function updateSubscriptionUnits(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\n     * holds. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     * @param userData Arbitrary user data field.\n     */\n    function updateSubscriptionUnits(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     */\n    function deleteSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     * @param userData Arbitrary user data field.\n     */\n    function deleteSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     */\n    function claim(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber\n    ) internal returns (bool) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     * @param userData Arbitrary user data field.\n     */\n    function claim(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory userData\n    ) internal returns (bool) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /** IDA WITH CTX FUNCTIONS ************************************* */\n\n    /**\n     * @dev Creates a new index with ctx.\n     * Meant for usage in super app callbacks\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function createIndexWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * Meant for usage in super app callbakcs\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     * @param ctx from super app callback\n     */\n    function updateIndexValueWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\n     * passing the new total index value, this function will increase the index value by `amount`.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount Amount by which the index value should increase.\n     * @param ctx from super app callback\n     */\n    function distributeWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function approveSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function revokeSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\n     * holds. Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     * @param ctx from super app callback\n     */\n    function updateSubscriptionUnitsWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\n     * Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     * @param ctx from super app callback\n     */\n    function deleteSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved.\n     * Meant for usage in super app callbacks\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     * @param ctx from super app callback\n     */\n    function claimWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    // ************** private helpers **************\n\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\")\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\")\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\");\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\n\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\n    // to be used in state changing methods\n    function _getAndCacheHostAndCFA(ISuperToken token) private\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            cfa := sload(_CFA_SLOT)\n        }\n        if (address(cfa) == address(0)) {\n            // framework contract addrs not yet cached, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\")\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\n            // now that we got them and are in a transaction context, persist in storage\n            assembly {\n            // solium-disable-line\n                sstore(_HOST_SLOT, host)\n                sstore(_CFA_SLOT, cfa)\n            }\n        }\n        assert(address(host) != address(0));\n        assert(address(cfa) != address(0));\n    }\n\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\n    // to be used in state changing methods\n    function _getAndCacheHostAndIDA(ISuperToken token) private\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            ida := sload(_IDA_SLOT)\n        }\n        if (address(ida) == address(0)) {\n            // framework contract addrs not yet cached, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                    keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\"))));\n            // now that we got them and are in a transaction context, persist in storage\n            assembly {\n            // solium-disable-line\n                sstore(_HOST_SLOT, host)\n                sstore(_IDA_SLOT, ida)\n            }\n        }\n        assert(address(host) != address(0));\n        assert(address(ida) != address(0));\n    }\n\n    // gets the host and cfa addrs for the token\n    // to be used in non-state changing methods (view functions)\n    function _getHostAndCFA(ISuperToken token) private view\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            cfa := sload(_CFA_SLOT)\n        }\n        if (address(cfa) == address(0)) {\n            // framework contract addrs not yet cached in storage, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\")\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\n        }\n        assert(address(host) != address(0));\n        assert(address(cfa) != address(0));\n    }\n\n    // gets the host and ida addrs for the token\n    // to be used in non-state changing methods (view functions)\n    function _getHostAndIDA(ISuperToken token) private view\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            ida := sload(_IDA_SLOT)\n        }\n        if (address(ida) == address(0)) {\n            // framework contract addrs not yet cached in storage, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\")\n                    0x15609310ae3c30189a1218b7adabaf36c267255e70cf91b6cba384367d9eda32)));\n        }\n        assert(address(host) != address(0));\n        assert(address(ida) != address(0));\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"../superfluid/ISuperAgreement.sol\";\nimport { ISuperfluidToken } from \"../superfluid/ISuperfluidToken.sol\";\n\n/**\n * @title Constant Flow Agreement interface\n * @author Superfluid\n */\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\n\n    /// @dev ISuperAgreement.agreementType implementation\n    function agreementType() external override pure returns (bytes32) {\n        return keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\");\n    }\n\n    /**\n     * @notice Get the maximum flow rate allowed with the deposit\n     * @dev The deposit is clipped and rounded down\n     * @param deposit Deposit amount used for creating the flow\n     * @return flowRate The maximum flow rate\n     */\n    function getMaximumFlowRateFromDeposit(\n        ISuperfluidToken token,\n        uint256 deposit)\n        external view virtual\n        returns (int96 flowRate);\n\n    /**\n     * @notice Get the deposit required for creating the flow\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\n     * @param flowRate Flow rate to be tested\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\n     * @custom:note \n     * - if calculated deposit (flowRate * liquidationPeriod) is less\n     *   than the minimum deposit, we use the minimum deposit otherwise\n     *   we use the calculated deposit\n     */\n    function getDepositRequiredForFlowRate(\n        ISuperfluidToken token,\n        int96 flowRate)\n        external view virtual\n        returns (uint256 deposit);\n\n    /**\n     * @dev Returns whether it is the patrician period based on host.getNow()\n     * @param account The account we are interested in\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\n     * @return timestamp The value of host.getNow()\n     */\n    function isPatricianPeriodNow(\n        ISuperfluidToken token,\n        address account)\n        external view virtual\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\n\n    /**\n     * @dev Returns whether it is the patrician period based on timestamp\n     * @param account The account we are interested in\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\n     * @return bool Whether it is currently the patrician period dictated by governance\n     */\n    function isPatricianPeriod(\n        ISuperfluidToken token,\n        address account,\n        uint256 timestamp\n    )\n        public view virtual\n        returns (bool);\n\n    /**\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param permissions A bitmask representation of the granted permissions\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowOperatorPermissions(\n        ISuperfluidToken token,\n        address flowOperator,\n        uint8 permissions,\n        int96 flowRateAllowance,\n        bytes calldata ctx\n    ) \n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice msgSender from `ctx` increases flow rate allowance for the `flowOperator` by `addedFlowRateAllowance`\n     * @dev if `addedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param addedFlowRateAllowance The flow rate allowance delta\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @return newCtx The new context bytes\n     */\n    function increaseFlowRateAllowance(\n        ISuperfluidToken token,\n        address flowOperator,\n        int96 addedFlowRateAllowance,\n        bytes calldata ctx\n    ) external virtual returns(bytes memory newCtx);\n\n    /**\n     * @dev msgSender from `ctx` decreases flow rate allowance for the `flowOperator` by `subtractedFlowRateAllowance`\n     * @dev if `subtractedFlowRateAllowance` is negative, we revert with CFA_ACL_NO_NEGATIVE_ALLOWANCE\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param subtractedFlowRateAllowance The flow rate allowance delta\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @return newCtx The new context bytes\n     */\n    function decreaseFlowRateAllowance(\n        ISuperfluidToken token,\n        address flowOperator,\n        int96 subtractedFlowRateAllowance,\n        bytes calldata ctx\n    ) external virtual returns(bytes memory newCtx);\n\n    /**\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function authorizeFlowOperatorWithFullControl(\n        ISuperfluidToken token,\n        address flowOperator,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n     /**\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function revokeFlowOperatorWithFullControl(\n        ISuperfluidToken token,\n        address flowOperator,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\n     * @param token Super token address\n     * @param sender The permission granter address\n     * @param flowOperator The permission grantee address\n     * @return flowOperatorId The keccak256 hash of encoded string \"flowOperator\", sender and flowOperator\n     * @return permissions A bitmask representation of the granted permissions\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    function getFlowOperatorData(\n       ISuperfluidToken token,\n       address sender,\n       address flowOperator\n    )\n        public view virtual\n        returns (\n            bytes32 flowOperatorId,\n            uint8 permissions,\n            int96 flowRateAllowance\n        );\n\n    /**\n     * @notice Get flow operator using flowOperatorId\n     * @param token Super token address\n     * @param flowOperatorId The keccak256 hash of encoded string \"flowOperator\", sender and flowOperator\n     * @return permissions A bitmask representation of the granted permissions\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    function getFlowOperatorDataByID(\n       ISuperfluidToken token,\n       bytes32 flowOperatorId\n    )\n        external view virtual\n        returns (\n            uint8 permissions,\n            int96 flowRateAllowance\n        );\n\n    /**\n     * @notice Create a flow betwen ctx.msgSender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param receiver Flow receiver address\n     * @param flowRate New flow rate in amount per second\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - AgreementCreated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - A deposit is taken as safety margin for the solvency agents\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\n     */\n    function createFlow(\n        ISuperfluidToken token,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n    * @notice Create a flow between sender and receiver\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\n    * @param token Super token address\n    * @param sender Flow sender address (has granted permissions)\n    * @param receiver Flow receiver address\n    * @param flowRate New flow rate in amount per second\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    */\n    function createFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Update the flow rate between ctx.msgSender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param receiver Flow receiver address\n     * @param flowRate New flow rate in amount per second\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - AgreementUpdated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - Only the flow sender may update the flow rate\n     * - Even if the flow rate is zero, the flow is not deleted\n     * from the system\n     * - Deposit amount will be adjusted accordingly\n     * - No new gas fee is charged\n     */\n    function updateFlow(\n        ISuperfluidToken token,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n    * @notice Update a flow between sender and receiver\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\n    * @param token Super token address\n    * @param sender Flow sender address (has granted permissions)\n    * @param receiver Flow receiver address\n    * @param flowRate New flow rate in amount per second\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    */\n    function updateFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @dev Get the flow data between `sender` and `receiver` of `token`\n     * @param token Super token address\n     * @param sender Flow receiver\n     * @param receiver Flow sender\n     * @return timestamp Timestamp of when the flow is updated\n     * @return flowRate The flow rate\n     * @return deposit The amount of deposit the flow\n     * @return owedDeposit The amount of owed deposit of the flow\n     */\n    function getFlow(\n        ISuperfluidToken token,\n        address sender,\n        address receiver\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n    /**\n     * @notice Get flow data using agreementId\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param agreementId The agreement ID\n     * @return timestamp Timestamp of when the flow is updated\n     * @return flowRate The flow rate\n     * @return deposit The deposit amount of the flow\n     * @return owedDeposit The owed deposit amount of the flow\n     */\n    function getFlowByID(\n       ISuperfluidToken token,\n       bytes32 agreementId\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n    /**\n     * @dev Get the aggregated flow info of the account\n     * @param token Super token address\n     * @param account Account for the query\n     * @return timestamp Timestamp of when a flow was last updated for account\n     * @return flowRate The net flow rate of token for account\n     * @return deposit The sum of all deposits for account's flows\n     * @return owedDeposit The sum of all owed deposits for account's flows\n     */\n    function getAccountFlowInfo(\n        ISuperfluidToken token,\n        address account\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit);\n\n    /**\n     * @dev Get the net flow rate of the account\n     * @param token Super token address\n     * @param account Account for the query\n     * @return flowRate Net flow rate\n     */\n    function getNetFlow(\n        ISuperfluidToken token,\n        address account\n    )\n        external view virtual\n        returns (int96 flowRate);\n\n    /**\n     * @notice Delete the flow between sender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver Flow receiver address\n     *\n     * @custom:callbacks \n     * - AgreementTerminated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - Both flow sender and receiver may delete the flow\n     * - If Sender account is insolvent or in critical state, a solvency agent may\n     *   also terminate the agreement\n     * - Gas fee may be returned to the sender\n     */\n    function deleteFlow(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Delete the flow between sender and receiver\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\n     * @param token Super token address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver Flow receiver address\n     */\n    function deleteFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n     \n    /**\n     * @dev Flow operator updated event\n     * @param token Super token address\n     * @param sender Flow sender address\n     * @param flowOperator Flow operator address\n     * @param permissions Octo bitmask representation of permissions\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    event FlowOperatorUpdated(\n        ISuperfluidToken indexed token,\n        address indexed sender,\n        address indexed flowOperator,\n        uint8 permissions,\n        int96 flowRateAllowance\n    );\n\n    /**\n     * @dev Flow updated event\n     * @param token Super token address\n     * @param sender Flow sender address\n     * @param receiver Flow recipient address\n     * @param flowRate Flow rate in amount per second for this flow\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\n     * @param userData The user provided data\n     *\n     */\n    event FlowUpdated(\n        ISuperfluidToken indexed token,\n        address indexed sender,\n        address indexed receiver,\n        int96 flowRate,\n        int256 totalSenderFlowRate,\n        int256 totalReceiverFlowRate,\n        bytes userData\n    );\n\n    /**\n     * @dev Flow updated extension event\n     * @param flowOperator Flow operator address - the Context.msgSender\n     * @param deposit The deposit amount for the stream\n     */\n    event FlowUpdatedExtension(\n        address indexed flowOperator,\n        uint256 deposit\n    );\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"../superfluid/ISuperAgreement.sol\";\nimport { ISuperfluidToken } from \"../superfluid/ISuperfluidToken.sol\";\n\n\n/**\n * @title Instant Distribution Agreement interface\n * @author Superfluid\n *\n * @notice \n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\n *       Despite knowing sha-3 collision is only theoretical.\n *   - A publisher can create a subscription to an index for any subscriber.\n *   - A subscription consists of:\n *     - The index it subscribes to.\n *     - Number of units subscribed.\n *   - An index consists of:\n *     - Current value as `uint128 indexValue`.\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\n *   - A publisher can update an index with a new value that doesn't decrease.\n *   - A publisher can update a subscription with any number of units.\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\n *   - A subscriber must approve the index in order to receive distributions from the publisher\n *     each time the index is updated.\n *     - The amount distributed is $$\\Delta{index} * units$$\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\n *     - the subscriber approves the subscription (side effect),\n *     - the publisher updates the subscription (side effect),\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\n *     - or the subscriber can explicitly claim them.\n */\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\n\n    /// @dev ISuperAgreement.agreementType implementation\n    function agreementType() external override pure returns (bytes32) {\n        return keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\");\n    }\n\n    /**************************************************************************\n     * Index operations\n     *************************************************************************/\n\n    /**\n     * @dev Create a new index for the publisher\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * None\n     */\n    function createIndex(\n        ISuperfluidToken token,\n        uint32 indexId,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n    * @dev Index created event\n    * @param token Super token address\n    * @param publisher Index creator and publisher\n    * @param indexId The specified indexId of the newly created index\n    * @param userData The user provided data\n    */\n    event IndexCreated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        bytes userData);\n\n    /**\n     * @dev Query the data of a index\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @return exist Does the index exist\n     * @return indexValue Value of the current index\n     * @return totalUnitsApproved Total units approved for the index\n     * @return totalUnitsPending Total units pending approval for the index\n     */\n    function getIndex(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId)\n            external\n            view\n            virtual\n            returns(\n                bool exist,\n                uint128 indexValue,\n                uint128 totalUnitsApproved,\n                uint128 totalUnitsPending);\n\n    /**\n     * @dev Calculate actual distribution amount\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param amount The amount of tokens desired to be distributed\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\n     */\n    function calculateDistribution(\n       ISuperfluidToken token,\n       address publisher,\n       uint32 indexId,\n       uint256 amount)\n           external view\n           virtual\n           returns(\n               uint256 actualAmount,\n               uint128 newIndexValue);\n\n    /**\n     * @dev Update index value of an index\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param indexValue Value of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * None\n     */\n    function updateIndex(\n        ISuperfluidToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n      * @dev Index updated event\n      * @param token Super token address\n      * @param publisher Index updater and publisher\n      * @param indexId The specified indexId of the updated index\n      * @param oldIndexValue The previous index value\n      * @param newIndexValue The updated index value\n      * @param totalUnitsPending The total units pending when the indexValue was updated\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\n      * @param userData The user provided data\n      */\n    event IndexUpdated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        uint128 oldIndexValue,\n        uint128 newIndexValue,\n        uint128 totalUnitsPending,\n        uint128 totalUnitsApproved,\n        bytes userData);\n\n    /**\n     * @dev Distribute tokens through the index\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param amount The amount of tokens desired to be distributed\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:note \n     * - This is a convenient version of updateIndex. It adds to the index\n     *   a delta that equals to `amount / totalUnits`\n     * - The actual amount distributed could be obtained via\n     *   `calculateDistribution`. This is due to precision error with index\n     *   value and units data range\n     *\n     * @custom:callbacks \n     * None\n     */\n    function distribute(\n        ISuperfluidToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n\n    /**************************************************************************\n     * Subscription operations\n     *************************************************************************/\n\n    /**\n     * @dev Approve the subscription of an index\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if subscription exist\n     *   - AgreementCreated callback to the publisher:\n     *      - agreementId is for the subscription\n     * - if subscription does not exist\n     *   - AgreementUpdated callback to the publisher:\n     *      - agreementId is for the subscription\n     */\n    function approveSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n      * @dev Index subscribed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The approved subscriber\n      * @param userData The user provided data\n      */\n    event IndexSubscribed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        bytes userData);\n\n    /**\n      * @dev Subscription approved event\n      * @param token Super token address\n      * @param subscriber The approved subscriber\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param userData The user provided data\n      */\n    event SubscriptionApproved(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        bytes userData);\n\n    /**\n    * @notice Revoke the subscription of an index\n    * @dev \"Unapproves\" the subscription and moves approved units to pending\n    * @param token Super token address\n    * @param publisher The publisher of the index\n    * @param indexId Id of the index\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    *\n    * @custom:callbacks \n    * - AgreementUpdated callback to the publisher:\n    *    - agreementId is for the subscription\n    */\n    function revokeSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        bytes calldata ctx)\n         external\n         virtual\n         returns(bytes memory newCtx);\n    /**\n      * @dev Index unsubscribed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The unsubscribed subscriber\n      * @param userData The user provided data\n      */\n    event IndexUnsubscribed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        bytes userData);\n    \n    /**\n      * @dev Subscription approved event\n      * @param token Super token address\n      * @param subscriber The approved subscriber\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param userData The user provided data\n      */\n    event SubscriptionRevoked(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        bytes userData);\n\n    /**\n     * @dev Update the nuber of units of a subscription\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param subscriber The subscriber of the index\n     * @param units Number of units of the subscription\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if subscription exist\n     *   - AgreementCreated callback to the subscriber:\n     *      - agreementId is for the subscription\n     * - if subscription does not exist\n     *   - AgreementUpdated callback to the subscriber:\n     *      - agreementId is for the subscription\n     */\n    function updateSubscription(\n        ISuperfluidToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n    /**\n      * @dev Index units updated event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The subscriber units updated\n      * @param units The new units amount\n      * @param userData The user provided data\n      */\n    event IndexUnitsUpdated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        uint128 units,\n        bytes userData);\n    \n    /**\n      * @dev Subscription units updated event\n      * @param token Super token address\n      * @param subscriber The subscriber units updated\n      * @param indexId The specified indexId\n      * @param publisher Index publisher\n      * @param units The new units amount\n      * @param userData The user provided data\n      */\n    event SubscriptionUnitsUpdated(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        uint128 units,\n        bytes userData);\n\n    /**\n     * @dev Get data of a subscription\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param subscriber The subscriber of the index\n     * @return exist Does the subscription exist?\n     * @return approved Is the subscription approved?\n     * @return units Units of the suscription\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\n     */\n    function getSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber)\n            external\n            view\n            virtual\n            returns(\n                bool exist,\n                bool approved,\n                uint128 units,\n                uint256 pendingDistribution\n            );\n\n    /**\n     * @notice Get data of a subscription by agreement ID\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\"publisher\", publisher, indexId)\n     * @param token Super token address\n     * @param agreementId The agreement ID\n     * @return publisher The publisher of the index\n     * @return indexId Id of the index\n     * @return approved Is the subscription approved?\n     * @return units Units of the suscription\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\n     */\n    function getSubscriptionByID(\n        ISuperfluidToken token,\n        bytes32 agreementId)\n            external\n            view\n            virtual\n            returns(\n                address publisher,\n                uint32 indexId,\n                bool approved,\n                uint128 units,\n                uint256 pendingDistribution\n            );\n\n    /**\n     * @dev List subscriptions of an user\n     * @param token Super token address\n     * @param subscriber The subscriber's address\n     * @return publishers Publishers of the subcriptions\n     * @return indexIds Indexes of the subscriptions\n     * @return unitsList Units of the subscriptions\n     */\n    function listSubscriptions(\n        ISuperfluidToken token,\n        address subscriber)\n            external\n            view\n            virtual\n            returns(\n                address[] memory publishers,\n                uint32[] memory indexIds,\n                uint128[] memory unitsList);\n\n    /**\n     * @dev Delete the subscription of an user\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param subscriber The subscriber's address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if the subscriber called it\n     *   - AgreementTerminated callback to the publsiher:\n     *      - agreementId is for the subscription\n     * - if the publisher called it\n     *   - AgreementTerminated callback to the subscriber:\n     *      - agreementId is for the subscription\n     */\n    function deleteSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n    /**\n    * @dev Claim pending distributions\n    * @param token Super token address\n    * @param publisher The publisher of the index\n    * @param indexId Id of the index\n    * @param subscriber The subscriber's address\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    *\n    * @custom:note The subscription should not be approved yet\n    *\n    * @custom:callbacks \n    * - AgreementUpdated callback to the publisher:\n    *    - agreementId is for the subscription\n    */\n    function claim(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes calldata ctx)\n        external\n        virtual\n        returns(bytes memory newCtx);\n    \n    /**\n      * @dev Index distribution claimed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The subscriber units updated\n      * @param amount The pending amount claimed\n      */\n    event IndexDistributionClaimed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        uint256 amount);\n    \n    /**\n      * @dev Subscription distribution claimed event\n      * @param token Super token address\n      * @param subscriber The subscriber units updated\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param amount The pending amount claimed\n      */\n    event SubscriptionDistributionClaimed(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        uint256 amount);\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\n/**\n * @title Super app definitions library\n * @author Superfluid\n */\nlibrary SuperAppDefinitions {\n\n    /**************************************************************************\n    / App manifest config word\n    /**************************************************************************/\n\n    /*\n     * App level is a way to allow the app to whitelist what other app it can\n     * interact with (aka. composite app feature).\n     *\n     * For more details, refer to the technical paper of superfluid protocol.\n     */\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\n\n    // The app is at the final level, hence it doesn't want to interact with any other app\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\n\n    // The app is at the second level, it may interact with other final level apps if whitelisted\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\n\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\n        return uint8(configWord & APP_LEVEL_MASK);\n    }\n\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\n    }\n\n    /**************************************************************************\n    / Callback implementation bit masks\n    /**************************************************************************/\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\n\n    /**************************************************************************\n    / App Jail Reasons\n    /**************************************************************************/\n\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\n\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\n    }\n}\n\n/**\n * @title Context definitions library\n * @author Superfluid\n */\nlibrary ContextDefinitions {\n\n    /**************************************************************************\n    / Call info\n    /**************************************************************************/\n\n    // app level\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\n\n    // call type\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\n\n    function decodeCallInfo(uint256 callInfo)\n        internal pure\n        returns (uint8 appCallbackLevel, uint8 callType)\n    {\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\n    }\n\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\n        internal pure\n        returns (uint256 callInfo)\n    {\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\n    }\n\n}\n\n/**\n * @title Flow Operator definitions library\n  * @author Superfluid\n */\n library FlowOperatorDefinitions {\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\n\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\n        return (\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\n            ) == uint8(0);\n    }\n }\n\n/**\n * @title Batch operation library\n * @author Superfluid\n */\nlibrary BatchOperation {\n    /**\n     * @dev ERC20.approve batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationApprove(\n     *     abi.decode(data, (address spender, uint256 amount))\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\n    /**\n     * @dev ERC20.transferFrom batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationTransferFrom(\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\n    /**\n     * @dev ERC777.send batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationSend(\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\n    /**\n     * @dev ERC20.increaseAllowance batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationIncreaseAllowance(\n     *     abi.decode(data, (address account, address spender, uint256 addedValue))\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_INCREASE_ALLOWANCE = 4;\n    /**\n     * @dev ERC20.decreaseAllowance batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationDecreaseAllowance(\n     *     abi.decode(data, (address account, address spender, uint256 subtractedValue))\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_DECREASE_ALLOWANCE = 5;\n    /**\n     * @dev SuperToken.upgrade batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationUpgrade(\n     *     abi.decode(data, (uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\n    /**\n     * @dev SuperToken.downgrade batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationDowngrade(\n     *     abi.decode(data, (uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\n    /**\n     * @dev Superfluid.callAgreement batch operation type\n     *\n     * Call spec:\n     * callAgreement(\n     *     ISuperAgreement(target)),\n     *     abi.decode(data, (bytes callData, bytes userData)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\n    /**\n     * @dev Superfluid.callAppAction batch operation type\n     *\n     * Call spec:\n     * callAppAction(\n     *     ISuperApp(target)),\n     *     data\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\n}\n\n/**\n * @title Superfluid governance configs library\n * @author Superfluid\n */\nlibrary SuperfluidGovernanceConfigs {\n\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\n        keccak256(\"org.superfluid-finance.superfluid.rewardAddress\");\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\n        keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\");\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\n        keccak256(\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\");\n\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.trustedForwarder\",\n            forwarder));\n    }\n\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\",\n            deployer,\n            registrationKey));\n    }\n\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32)\n    {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.appWhiteListing.factory\",\n            factory));\n    }\n\n    function decodePPPConfig(uint256 pppConfig) internal pure\n        returns (uint256 liquidationPeriod, uint256 patricianPeriod)\n    {\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\n        patricianPeriod = pppConfig & type(uint32).max;\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantInflowNFT.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.8.4;\n\nimport { ISuperToken } from \"./ISuperToken.sol\";\nimport { IFlowNFTBase } from \"./IFlowNFTBase.sol\";\n\ninterface IConstantInflowNFT is IFlowNFTBase {\n    /**************************************************************************\n     * Custom Errors\n     *************************************************************************/\n    error CIF_NFT_ONLY_CONSTANT_OUTFLOW(); // 0xe81ef57a\n\n    /**************************************************************************\n     * Write Functions\n     *************************************************************************/\n\n    /// @notice The mint function emits the \"mint\" `Transfer` event.\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\n    /// is to inform clients that search for events.\n    /// @param to the flow receiver (inflow NFT receiver)\n    /// @param newTokenId the new token id\n    function mint(address to, uint256 newTokenId) external;\n\n    /// @notice This burn function emits the \"burn\" `Transfer` event.\n    /// @dev We don't modify storage as this is handled in ConstantOutflowNFT.sol and this function's sole purpose\n    /// is to inform clients that search for events.\n    /// @param tokenId desired token id to burn\n    function burn(uint256 tokenId) external;\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IConstantOutflowNFT.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.8.4;\n\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\nimport { IFlowNFTBase } from \"./IFlowNFTBase.sol\";\n\ninterface IConstantOutflowNFT is IFlowNFTBase {\n    /**************************************************************************\n     * Custom Errors\n     *************************************************************************/\n\n    error COF_NFT_INVALID_SUPER_TOKEN();            // 0x6de98774\n    error COF_NFT_MINT_TO_AND_FLOW_RECEIVER_SAME(); // 0x0d1d1161\n    error COF_NFT_MINT_TO_ZERO_ADDRESS();           // 0x43d05e51\n    error COF_NFT_ONLY_CONSTANT_INFLOW();           // 0xa495a718\n    error COF_NFT_ONLY_FLOW_AGREEMENTS();           // 0xd367b64f\n    error COF_NFT_TOKEN_ALREADY_EXISTS();           // 0xe2480183\n\n\n    /**************************************************************************\n     * Write Functions\n     *************************************************************************/\n\n    /// @notice The onCreate function is called when a new flow is created.\n    /// @param token the super token passed from the CFA (flowVars)\n    /// @param flowSender the flow sender\n    /// @param flowReceiver the flow receiver\n    function onCreate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\n\n    /// @notice The onUpdate function is called when a flow is updated.\n    /// @param token the super token passed from the CFA (flowVars)\n    /// @param flowSender the flow sender\n    /// @param flowReceiver the flow receiver\n    function onUpdate(ISuperfluidToken token, address flowSender, address flowReceiver) external;\n\n    /// @notice The onDelete function is called when a flow is deleted.\n    /// @param token the super token passed from the CFA (flowVars)\n    /// @param flowSender the flow sender\n    /// @param flowReceiver the flow receiver\n    function onDelete(ISuperfluidToken token, address flowSender, address flowReceiver) external;\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IFlowNFTBase.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.8.4;\n\nimport {\n    IERC721Metadata\n} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { ISuperToken } from \"./ISuperToken.sol\";\n\ninterface IFlowNFTBase is IERC721Metadata {\n    // FlowNFTData struct storage packing:\n    // b = bits\n    // WORD 1: | superToken      | FREE\n    //         | 160b            | 96b\n    // WORD 2: | flowSender      | FREE\n    //         | 160b            | 96b\n    // WORD 3: | flowReceiver    | flowStartDate | FREE\n    //         | 160b            | 32b           | 64b\n    struct FlowNFTData {\n        address superToken;\n        address flowSender;\n        address flowReceiver;\n        uint32 flowStartDate;\n    }\n\n    /**************************************************************************\n     * Custom Errors\n     *************************************************************************/\n\n    error CFA_NFT_APPROVE_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();   // 0xa3352582\n    error CFA_NFT_APPROVE_TO_CALLER();                              // 0xd3c77329\n    error CFA_NFT_APPROVE_TO_CURRENT_OWNER();                       // 0xe4790b25\n    error CFA_NFT_INVALID_TOKEN_ID();                               // 0xeab95e3b\n    error CFA_NFT_ONLY_SUPER_TOKEN_FACTORY();                       // 0xebb7505b\n    error CFA_NFT_TRANSFER_CALLER_NOT_OWNER_OR_APPROVED_FOR_ALL();  // 0x2551d606\n    error CFA_NFT_TRANSFER_FROM_INCORRECT_OWNER();                  // 0x5a26c744\n    error CFA_NFT_TRANSFER_IS_NOT_ALLOWED();                        // 0xaa747eca\n    error CFA_NFT_TRANSFER_TO_ZERO_ADDRESS();                       // 0xde06d21e\n\n    /**************************************************************************\n     * Events\n     *************************************************************************/\n\n    /// @notice Informs third-party platforms that NFT metadata should be updated\n    /// @dev This event comes from https://eips.ethereum.org/EIPS/eip-4906\n    /// @param tokenId the id of the token that should have its metadata updated\n    event MetadataUpdate(uint256 tokenId);\n\n    /**************************************************************************\n     * View\n     *************************************************************************/\n\n    /// @notice An external function for querying flow data by `tokenId``\n    /// @param tokenId the token id\n    /// @return flowData the flow data associated with `tokenId`\n    function flowDataByTokenId(\n        uint256 tokenId\n    ) external view returns (FlowNFTData memory flowData);\n\n    /// @notice An external function for computing the deterministic tokenId\n    /// @dev tokenId = uint256(keccak256(abi.encode(block.chainId, superToken, flowSender, flowReceiver)))\n    /// @param superToken the super token\n    /// @param flowSender the flow sender\n    /// @param flowReceiver the flow receiver\n    /// @return tokenId the tokenId\n    function getTokenId(\n        address superToken,\n        address flowSender,\n        address flowReceiver\n    ) external view returns (uint256);\n\n    /**************************************************************************\n     * Write\n     *************************************************************************/\n\n    function initialize(\n        string memory nftName,\n        string memory nftSymbol\n    ) external; // initializer;\n\n    function triggerMetadataUpdate(uint256 tokenId) external;\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolAdminNFT.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.8.4;\n\ninterface IPoolAdminNFT {}"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/IPoolMemberNFT.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.8.4;\n\ninterface IPoolMemberNFT {}"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\n\n/**\n * @title Super agreement interface\n * @author Superfluid\n */\ninterface ISuperAgreement {\n\n    /**\n     * @dev Get the type of the agreement class\n     */\n    function agreementType() external view returns (bytes32);\n\n    /**\n     * @dev Calculate the real-time balance for the account of this agreement class\n     * @param account Account the state belongs to\n     * @param time Time used for the calculation\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\n     * @return deposit Account deposit amount of this agreement\n     * @return owedDeposit Account owed deposit amount of this agreement\n     */\n    function realtimeBalanceOf(\n        ISuperfluidToken token,\n        address account,\n        uint256 time\n    )\n        external\n        view\n        returns (\n            int256 dynamicBalance,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperToken } from \"./ISuperToken.sol\";\n\n/**\n * @title SuperApp interface\n * @author Superfluid\n * @dev Be aware of the app being jailed, when the word permitted is used.\n */\ninterface ISuperApp {\n\n    /**\n     * @dev Callback before a new agreement is created.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param ctx The context data.\n     * @return cbdata A free format in memory data the app can use to pass\n     *          arbitary information to the after-hook callback.\n     *\n     * @custom:note \n     * - It will be invoked with `staticcall`, no state changes are permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function beforeAgreementCreated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n    /**\n     * @dev Callback after a new agreement is created.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param cbdata The data returned from the before-hook callback.\n     * @param ctx The context data.\n     * @return newCtx The current context of the transaction.\n     *\n     * @custom:note \n     * - State changes is permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function afterAgreementCreated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev Callback before a new agreement is updated.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param ctx The context data.\n     * @return cbdata A free format in memory data the app can use to pass\n     *          arbitary information to the after-hook callback.\n     *\n     * @custom:note \n     * - It will be invoked with `staticcall`, no state changes are permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function beforeAgreementUpdated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n\n    /**\n    * @dev Callback after a new agreement is updated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param cbdata The data returned from the before-hook callback.\n    * @param ctx The context data.\n    * @return newCtx The current context of the transaction.\n    *\n    * @custom:note \n    * - State changes is permitted.\n    * - Only revert with a \"reason\" is permitted.\n    */\n    function afterAgreementUpdated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n\n    /**\n    * @dev Callback before a new agreement is terminated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param ctx The context data.\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to\n    *         the after-hook callback.\n    *\n    * @custom:note \n    * - It will be invoked with `staticcall`, no state changes are permitted.\n    * - Revert is not permitted.\n    */\n    function beforeAgreementTerminated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n    /**\n    * @dev Callback after a new agreement is terminated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param cbdata The data returned from the before-hook callback.\n    * @param ctx The context data.\n    * @return newCtx The current context of the transaction.\n    *\n    * @custom:note \n    * - State changes is permitted.\n    * - Revert is not permitted.\n    */\n    function afterAgreementTerminated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluidGovernance } from \"./ISuperfluidGovernance.sol\";\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\nimport { ISuperToken } from \"./ISuperToken.sol\";\nimport { ISuperTokenFactory } from \"./ISuperTokenFactory.sol\";\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\nimport { ISuperApp } from \"./ISuperApp.sol\";\nimport {\n    BatchOperation,\n    ContextDefinitions,\n    FlowOperatorDefinitions,\n    SuperAppDefinitions,\n    SuperfluidGovernanceConfigs\n} from \"./Definitions.sol\";\nimport { TokenInfo } from \"../tokens/TokenInfo.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\n\n/**\n * @title Host interface\n * @author Superfluid\n * @notice This is the central contract of the system where super agreement, super app\n * and super token features are connected.\n *\n * The Superfluid host contract is also the entry point for the protocol users,\n * where batch call and meta transaction are provided for UX improvements.\n *\n */\ninterface ISuperfluid {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    // Superfluid Custom Errors\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\n\n    // App Related Custom Errors\n    // uses SuperAppDefinitions' App Jail Reasons as _code\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\n\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\n\n    /**************************************************************************\n     * Time\n     *\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\n     * > Neo: Then why can't I see what happens to her?\n     * > The Oracle: We can never see past the choices we don't understand.\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\n     *************************************************************************/\n\n    function getNow() external view returns (uint256);\n\n    /**************************************************************************\n     * Governance\n     *************************************************************************/\n\n    /**\n     * @dev Get the current governance address of the Superfluid host\n     */\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\n\n    /**\n     * @dev Replace the current governance with a new one\n     */\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\n    /**\n     * @dev Governance replaced event\n     * @param oldGov Address of the old governance contract\n     * @param newGov Address of the new governance contract\n     */\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\n\n    /**************************************************************************\n     * Agreement Whitelisting\n     *************************************************************************/\n\n    /**\n     * @dev Register a new agreement class to the system\n     * @param agreementClassLogic Initial agreement class code\n     *\n     * @custom:modifiers \n     * - onlyGovernance\n     */\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\n    /**\n     * @notice Agreement class registered event\n     * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n     * @param agreementType The agreement type registered\n     * @param code Address of the new agreement\n     */\n    event AgreementClassRegistered(bytes32 agreementType, address code);\n\n    /**\n    * @dev Update code of an agreement class\n    * @param agreementClassLogic New code for the agreement class\n    *\n    * @custom:modifiers \n    *  - onlyGovernance\n    */\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\n    /**\n     * @notice Agreement class updated event\n     * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n     * @param agreementType The agreement type updated\n     * @param code Address of the new agreement\n     */\n    event AgreementClassUpdated(bytes32 agreementType, address code);\n\n    /**\n    * @notice Check if the agreement type is whitelisted\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    */\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\n\n    /**\n    * @dev Check if the agreement class is whitelisted\n    */\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\n\n    /**\n    * @notice Get agreement class\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    */\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\n\n    /**\n    * @dev Map list of the agreement classes using a bitmap\n    * @param bitmap Agreement class bitmap\n    */\n    function mapAgreementClasses(uint256 bitmap)\n        external view\n        returns (ISuperAgreement[] memory agreementClasses);\n\n    /**\n    * @notice Create a new bitmask by adding a agreement class to it\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    * @param bitmap Agreement class bitmap\n    */\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\n        external view\n        returns (uint256 newBitmap);\n\n    /**\n    * @notice Create a new bitmask by removing a agreement class from it\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    * @param bitmap Agreement class bitmap\n    */\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\n        external view\n        returns (uint256 newBitmap);\n\n    /**************************************************************************\n    * Super Token Factory\n    **************************************************************************/\n\n    /**\n     * @dev Get the super token factory\n     * @return factory The factory\n     */\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\n\n    /**\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\n     * @return logic The factory logic\n     */\n    function getSuperTokenFactoryLogic() external view returns (address logic);\n\n    /**\n     * @dev Update super token factory\n     * @param newFactory New factory logic\n     */\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\n    /**\n     * @dev SuperToken factory updated event\n     * @param newFactory Address of the new factory\n     */\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\n\n    /**\n     * @notice Update the super token logic to the latest\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\n     */\n    function updateSuperTokenLogic(ISuperToken token) external;\n    /**\n     * @dev SuperToken logic updated event\n     * @param code Address of the new SuperToken logic\n     */\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\n\n    /**************************************************************************\n     * App Registry\n     *************************************************************************/\n\n    /**\n     * @dev Message sender (must be a contract) declares itself as a super app.\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\n     * because app registration is currently governance permissioned on mainnets.\n     * @param configWord The super app manifest configuration, flags are defined in\n     * `SuperAppDefinitions`\n     */\n    function registerApp(uint256 configWord) external;\n    /**\n     * @dev App registered event\n     * @param app Address of jailed app\n     */\n    event AppRegistered(ISuperApp indexed app);\n\n    /**\n     * @dev Message sender declares itself as a super app.\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\n     * must be the deployer account the registration key was issued for.\n     */\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\n\n    /**\n     * @dev Message sender (must be a contract) declares app as a super app\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\n     */\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\n\n    /**\n     * @dev Query if the app is registered\n     * @param app Super app address\n     */\n    function isApp(ISuperApp app) external view returns(bool);\n\n    /**\n     * @dev Query app callbacklevel\n     * @param app Super app address\n     */\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\n\n    /**\n     * @dev Get the manifest of the super app\n     * @param app Super app address\n     */\n    function getAppManifest(\n        ISuperApp app\n    )\n        external view\n        returns (\n            bool isSuperApp,\n            bool isJailed,\n            uint256 noopMask\n        );\n\n    /**\n     * @dev Query if the app has been jailed\n     * @param app Super app address\n     */\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\n\n    /**\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\n     * @param targetApp The target super app address\n     */\n    function allowCompositeApp(ISuperApp targetApp) external;\n\n    /**\n     * @dev Query if source app is allowed to call the target app as downstream app\n     * @param app Super app address\n     * @param targetApp The target super app address\n     */\n    function isCompositeAppAllowed(\n        ISuperApp app,\n        ISuperApp targetApp\n    )\n        external view\n        returns (bool isAppAllowed);\n\n    /**************************************************************************\n     * Agreement Framework\n     *\n     * Agreements use these function to trigger super app callbacks, updates\n     * app credit and charge gas fees.\n     *\n     * These functions can only be called by registered agreements.\n     *************************************************************************/\n\n    /**\n     * @dev (For agreements) StaticCall the app before callback\n     * @param  app               The super app.\n     * @param  callData          The call data sending to the super app.\n     * @param  isTermination     Is it a termination callback?\n     * @param  ctx               Current ctx, it will be validated.\n     * @return cbdata            Data returned from the callback.\n     */\n    function callAppBeforeCallback(\n        ISuperApp app,\n        bytes calldata callData,\n        bool isTermination,\n        bytes calldata ctx\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns(bytes memory cbdata);\n\n    /**\n     * @dev (For agreements) Call the app after callback\n     * @param  app               The super app.\n     * @param  callData          The call data sending to the super app.\n     * @param  isTermination     Is it a termination callback?\n     * @param  ctx               Current ctx, it will be validated.\n     * @return newCtx            The current context of the transaction.\n     */\n    function callAppAfterCallback(\n        ISuperApp app,\n        bytes calldata callData,\n        bool isTermination,\n        bytes calldata ctx\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns(bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Create a new callback stack\n     * @param  ctx                     The current ctx, it will be validated.\n     * @param  app                     The super app.\n     * @param  appCreditGranted        App credit granted so far.\n     * @param  appCreditUsed           App credit used so far.\n     * @return newCtx                  The current context of the transaction.\n     */\n    function appCallbackPush(\n        bytes calldata ctx,\n        ISuperApp app,\n        uint256 appCreditGranted,\n        int256 appCreditUsed,\n        ISuperfluidToken appCreditToken\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Pop from the current app callback stack\n     * @param  ctx                     The ctx that was pushed before the callback stack.\n     * @param  appCreditUsedDelta      App credit used by the app.\n     * @return newCtx                  The current context of the transaction.\n     *\n     * @custom:security\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\n     */\n    function appCallbackPop(\n        bytes calldata ctx,\n        int256 appCreditUsedDelta\n    )\n        external\n        // onlyAgreement\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Use app credit.\n     * @param  ctx                      The current ctx, it will be validated.\n     * @param  appCreditUsedMore        See app credit for more details.\n     * @return newCtx                   The current context of the transaction.\n     */\n    function ctxUseCredit(\n        bytes calldata ctx,\n        int256 appCreditUsedMore\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Jail the app.\n     * @param  app                     The super app.\n     * @param  reason                  Jail reason code.\n     * @return newCtx                  The current context of the transaction.\n     */\n    function jailApp(\n        bytes calldata ctx,\n        ISuperApp app,\n        uint256 reason\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev Jail event for the app\n     * @param app Address of jailed app\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\n     */\n    event Jail(ISuperApp indexed app, uint256 reason);\n\n    /**************************************************************************\n     * Contextless Call Proxies\n     *\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\n     * with agreements or apps.\n     *\n     * NOTE: The contextual call data should be generated using\n     * abi.encodeWithSelector. The context parameter should be set to \"0x\",\n     * an empty bytes array as a placeholder to be replaced by the host\n     * contract.\n     *************************************************************************/\n\n     /**\n      * @dev Call agreement function\n      * @param agreementClass The agreement address you are calling\n      * @param callData The contextual call data with placeholder ctx\n      * @param userData Extra user data being sent to the super app callbacks\n      */\n     function callAgreement(\n         ISuperAgreement agreementClass,\n         bytes calldata callData,\n         bytes calldata userData\n     )\n        external\n        //cleanCtx\n        //isAgreement(agreementClass)\n        returns(bytes memory returnedData);\n\n    /**\n     * @notice Call app action\n     * @dev Main use case is calling app action in a batch call via the host\n     * @param callData The contextual call data\n     *\n     * @custom:note See \"Contextless Call Proxies\" above for more about contextual call data.\n     */\n    function callAppAction(\n        ISuperApp app,\n        bytes calldata callData\n    )\n        external\n        //cleanCtx\n        //isAppActive(app)\n        //isValidAppAction(callData)\n        returns(bytes memory returnedData);\n\n    /**************************************************************************\n     * Contextual Call Proxies and Context Utilities\n     *\n     * For apps, they must use context they receive to interact with\n     * agreements or apps.\n     *\n     * The context changes must be saved and returned by the apps in their\n     * callbacks always, any modification to the context will be detected and\n     * the violating app will be jailed.\n     *************************************************************************/\n\n    /**\n     * @dev Context Struct\n     *\n     * @custom:note on backward compatibility:\n     * - Non-dynamic fields are padded to 32bytes and packed\n     * - Dynamic fields are referenced through a 32bytes offset to their \"parents\" field (or root)\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\n     *    - non-dynamic fields will be parsed at the same memory location,\n     *    - and dynamic fields will simply have a greater offset than it was.\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\n     */\n    struct Context {\n        //\n        // Call context\n        //\n        // app callback level\n        uint8 appCallbackLevel;\n        // type of call\n        uint8 callType;\n        // the system timestamp\n        uint256 timestamp;\n        // The intended message sender for the call\n        address msgSender;\n\n        //\n        // Callback context\n        //\n        // For callbacks it is used to know which agreement function selector is called\n        bytes4 agreementSelector;\n        // User provided data for app callbacks\n        bytes userData;\n\n        //\n        // App context\n        //\n        // app credit granted\n        uint256 appCreditGranted;\n        // app credit wanted by the app callback\n        uint256 appCreditWantedDeprecated;\n        // app credit used, allowing negative values over a callback session\n        // the appCreditUsed value over a callback sessions is calculated with:\n        // existing flow data owed deposit + sum of the callback agreements\n        // deposit deltas \n        // the final value used to modify the state is determined by the\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes \n        // the appCreditUsed value reached in the callback session and the app\n        // credit granted\n        int256 appCreditUsed;\n        // app address\n        address appAddress;\n        // app credit in super token\n        ISuperfluidToken appCreditToken;\n    }\n\n    function callAgreementWithContext(\n        ISuperAgreement agreementClass,\n        bytes calldata callData,\n        bytes calldata userData,\n        bytes calldata ctx\n    )\n        external\n        // requireValidCtx(ctx)\n        // onlyAgreement(agreementClass)\n        returns (bytes memory newCtx, bytes memory returnedData);\n\n    function callAppActionWithContext(\n        ISuperApp app,\n        bytes calldata callData,\n        bytes calldata ctx\n    )\n        external\n        // requireValidCtx(ctx)\n        // isAppActive(app)\n        returns (bytes memory newCtx);\n\n    function decodeCtx(bytes memory ctx)\n        external pure\n        returns (Context memory context);\n\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\n\n    /**************************************************************************\n    * Batch call\n    **************************************************************************/\n    /**\n     * @dev Batch operation data\n     */\n    struct Operation {\n        // Operation type. Defined in BatchOperation (Definitions.sol)\n        uint32 operationType;\n        // Operation target\n        address target;\n        // Data specific to the operation\n        bytes data;\n    }\n\n    /**\n     * @dev Batch call function\n     * @param operations Array of batch operations\n     */\n    function batchCall(Operation[] calldata operations) external;\n\n    /**\n     * @dev Batch call function for trusted forwarders (EIP-2771)\n     * @param operations Array of batch operations\n     */\n    function forwardBatchCall(Operation[] calldata operations) external;\n\n    /**************************************************************************\n     * Function modifiers for access control and parameter validations\n     *\n     * While they cannot be explicitly stated in function definitions, they are\n     * listed in function definition comments instead for clarity.\n     *\n     * TODO: turning these off because solidity-coverage doesn't like it\n     *************************************************************************/\n\n     /* /// @dev The current superfluid context is clean.\n     modifier cleanCtx() virtual;\n\n     /// @dev Require the ctx being valid.\n     modifier requireValidCtx(bytes memory ctx) virtual;\n\n     /// @dev Assert the ctx being valid.\n     modifier assertValidCtx(bytes memory ctx) virtual;\n\n     /// @dev The agreement is a listed agreement.\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\n\n     // onlyGovernance\n\n     /// @dev The msg.sender must be a listed agreement.\n     modifier onlyAgreement() virtual;\n\n     /// @dev The app is registered and not jailed.\n     modifier isAppActive(ISuperApp app) virtual; */\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\nimport { ISuperToken } from \"./ISuperToken.sol\";\nimport { ISuperfluidToken  } from \"./ISuperfluidToken.sol\";\nimport { ISuperfluid } from \"./ISuperfluid.sol\";\n\n\n/**\n * @title Superfluid governance interface\n * @author Superfluid\n */\ninterface ISuperfluidGovernance {\n    \n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SF_GOV_ARRAYS_NOT_SAME_LENGTH();                  // 0x27743aa6\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\n\n    /**\n     * @dev Replace the current governance with a new governance\n     */\n    function replaceGovernance(\n        ISuperfluid host,\n        address newGov) external;\n\n    /**\n     * @dev Register a new agreement class\n     */\n    function registerAgreementClass(\n        ISuperfluid host,\n        address agreementClass) external;\n\n    /**\n     * @dev Update logics of the contracts\n     *\n     * @custom:note \n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\n     */\n    function updateContracts(\n        ISuperfluid host,\n        address hostNewLogic,\n        address[] calldata agreementClassNewLogics,\n        address superTokenFactoryNewLogic\n    ) external;\n\n    /**\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\n     */\n    function batchUpdateSuperTokenLogic(\n        ISuperfluid host,\n        ISuperToken[] calldata tokens) external;\n    \n    /**\n     * @dev Set configuration as address value\n     */\n    function setConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key,\n        address value\n    ) external;\n    \n    /**\n     * @dev Set configuration as uint256 value\n     */\n    function setConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key,\n        uint256 value\n    ) external;\n\n    /**\n     * @dev Clear configuration\n     */\n    function clearConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key\n    ) external;\n\n    /**\n     * @dev Get configuration as address value\n     */\n    function getConfigAsAddress(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key) external view returns (address value);\n\n    /**\n     * @dev Get configuration as uint256 value\n     */\n    function getConfigAsUint256(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key) external view returns (uint256 value);\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\n\n/**\n * @title Superfluid token interface\n * @author Superfluid\n */\ninterface ISuperfluidToken {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\n\n    /**************************************************************************\n     * Basic information\n     *************************************************************************/\n\n    /**\n     * @dev Get superfluid host contract address\n     */\n    function getHost() external view returns(address host);\n\n    /**\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\n     *\n     * @custom:note \n     * - version: 1\n     * - liquidationType key:\n     *    - 0 = reward account receives reward (PIC period)\n     *    - 1 = liquidator account receives reward (Pleb period)\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\n     */\n    struct LiquidationTypeData {\n        uint256 version;\n        uint8 liquidationType;\n    }\n\n    /**************************************************************************\n     * Real-time balance functions\n     *************************************************************************/\n\n    /**\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\n    * @param account for the query\n    * @param timestamp Time of balance\n    * @return availableBalance Real-time balance\n    * @return deposit Account deposit\n    * @return owedDeposit Account owed Deposit\n    */\n    function realtimeBalanceOf(\n       address account,\n       uint256 timestamp\n    )\n        external view\n        returns (\n            int256 availableBalance,\n            uint256 deposit,\n            uint256 owedDeposit);\n\n    /**\n     * @notice Calculate the realtime balance given the current host.getNow() value\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\n     * @param account for the query\n     * @return availableBalance Real-time balance\n     * @return deposit Account deposit\n     * @return owedDeposit Account owed Deposit\n     */\n    function realtimeBalanceOfNow(\n       address account\n    )\n        external view\n        returns (\n            int256 availableBalance,\n            uint256 deposit,\n            uint256 owedDeposit,\n            uint256 timestamp);\n\n    /**\n    * @notice Check if account is critical\n    * @dev A critical account is when availableBalance < 0\n    * @param account The account to check\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\n    * @return isCritical Whether the account is critical\n    */\n    function isAccountCritical(\n        address account,\n        uint256 timestamp\n    )\n        external view\n        returns(bool isCritical);\n\n    /**\n    * @notice Check if account is critical now (current host.getNow())\n    * @dev A critical account is when availableBalance < 0\n    * @param account The account to check\n    * @return isCritical Whether the account is critical\n    */\n    function isAccountCriticalNow(\n        address account\n    )\n        external view\n        returns(bool isCritical);\n\n    /**\n     * @notice Check if account is solvent\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\n     * @param account The account to check\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\n     * @return isSolvent True if the account is solvent, false otherwise\n     */\n    function isAccountSolvent(\n        address account,\n        uint256 timestamp\n    )\n        external view\n        returns(bool isSolvent);\n\n    /**\n     * @notice Check if account is solvent now\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\n     * @param account The account to check\n     * @return isSolvent True if the account is solvent, false otherwise\n     */\n    function isAccountSolventNow(\n        address account\n    )\n        external view\n        returns(bool isSolvent);\n\n    /**\n    * @notice Get a list of agreements that is active for the account\n    * @dev An active agreement is one that has state for the account\n    * @param account Account to query\n    * @return activeAgreements List of accounts that have non-zero states for the account\n    */\n    function getAccountActiveAgreements(address account)\n       external view\n       returns(ISuperAgreement[] memory activeAgreements);\n\n\n   /**************************************************************************\n    * Super Agreement hosting functions\n    *************************************************************************/\n\n    /**\n     * @dev Create a new agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    function createAgreement(\n        bytes32 id,\n        bytes32[] calldata data\n    )\n        external;\n    /**\n     * @dev Agreement created event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    event AgreementCreated(\n        address indexed agreementClass,\n        bytes32 id,\n        bytes32[] data\n    );\n\n    /**\n     * @dev Get data of the agreement\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @return data Data of the agreement\n     */\n    function getAgreementData(\n        address agreementClass,\n        bytes32 id,\n        uint dataLength\n    )\n        external view\n        returns(bytes32[] memory data);\n\n    /**\n     * @dev Create a new agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    function updateAgreementData(\n        bytes32 id,\n        bytes32[] calldata data\n    )\n        external;\n    /**\n     * @dev Agreement updated event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    event AgreementUpdated(\n        address indexed agreementClass,\n        bytes32 id,\n        bytes32[] data\n    );\n\n    /**\n     * @dev Close the agreement\n     * @param id Agreement ID\n     */\n    function terminateAgreement(\n        bytes32 id,\n        uint dataLength\n    )\n        external;\n    /**\n     * @dev Agreement terminated event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     */\n    event AgreementTerminated(\n        address indexed agreementClass,\n        bytes32 id\n    );\n\n    /**\n     * @dev Update agreement state slot\n     * @param account Account to be updated\n     *\n     * @custom:note \n     * - To clear the storage out, provide zero-ed array of intended length\n     */\n    function updateAgreementStateSlot(\n        address account,\n        uint256 slotId,\n        bytes32[] calldata slotData\n    )\n        external;\n    /**\n     * @dev Agreement account state updated event\n     * @param agreementClass Contract address of the agreement\n     * @param account Account updated\n     * @param slotId slot id of the agreement state\n     */\n    event AgreementStateUpdated(\n        address indexed agreementClass,\n        address indexed account,\n        uint256 slotId\n    );\n\n    /**\n     * @dev Get data of the slot of the state of an agreement\n     * @param agreementClass Contract address of the agreement\n     * @param account Account to query\n     * @param slotId slot id of the state\n     * @param dataLength length of the state data\n     */\n    function getAgreementStateSlot(\n        address agreementClass,\n        address account,\n        uint256 slotId,\n        uint dataLength\n    )\n        external view\n        returns (bytes32[] memory slotData);\n\n    /**\n     * @notice Settle balance from an account by the agreement\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\n     * @param account Account to query.\n     * @param delta Amount of balance delta to be settled\n     *\n     * @custom:modifiers \n     *  - onlyAgreement\n     */\n    function settleBalance(\n        address account,\n        int256 delta\n    )\n        external;\n\n    /**\n     * @dev Make liquidation payouts (v2)\n     * @param id Agreement ID\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\n     * @param liquidatorAccount Address of the executor of the liquidation\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\n     * @param targetAccount Account to be liquidated\n     * @param rewardAmount The amount the rewarded account will receive\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\n     *\n     * @custom:note \n     * - If a bailout is required (bailoutAmount > 0)\n     *   - the actual reward (single deposit) goes to the executor,\n     *   - while the reward account becomes the bailout account\n     *   - total bailout include: bailout amount + reward amount\n     *   - the targetAccount will be bailed out\n     * - If a bailout is not required\n     *   - the targetAccount will pay the rewardAmount\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\n     *\n     * @custom:modifiers \n     *  - onlyAgreement\n     */\n    function makeLiquidationPayoutsV2\n    (\n        bytes32 id,\n        bytes memory liquidationTypeData,\n        address liquidatorAccount,\n        bool useDefaultRewardAccount,\n        address targetAccount,\n        uint256 rewardAmount,\n        int256 targetAccountBalanceDelta\n    ) external;\n    /**\n     * @dev Agreement liquidation event v2 (including agent account)\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param liquidatorAccount Address of the executor of the liquidation\n     * @param targetAccount Account of the stream sender\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\n     * @param rewardAmount The amount the reward recipient account balance should change by\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\n     *\n     * @custom:note \n     * Reward account rule:\n     * - if the agreement is liquidated during the PIC period\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\n     *   - the targetAccount will pay for the rewardAmount\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\n     *   - the targetAccount will pay for the rewardAmount\n     * - if the targetAccount is insolvent\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\n     *   - the targetAccount will receive the bailoutAmount\n     */\n    event AgreementLiquidatedV2(\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed liquidatorAccount,\n        address indexed targetAccount,\n        address rewardAmountReceiver,\n        uint256 rewardAmount,\n        int256 targetAccountBalanceDelta,\n        bytes liquidationTypeData\n    );\n\n    /**************************************************************************\n     * Function modifiers for access control and parameter validations\n     *\n     * While they cannot be explicitly stated in function definitions, they are\n     * listed in function definition comments instead for clarity.\n     *\n     * NOTE: solidity-coverage not supporting it\n     *************************************************************************/\n\n     /// @dev The msg.sender must be host contract\n     //modifier onlyHost() virtual;\n\n    /// @dev The msg.sender must be a listed agreement.\n    //modifier onlyAgreement() virtual;\n\n    /**************************************************************************\n     * DEPRECATED\n     *************************************************************************/\n\n    /**\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param penaltyAccount Account of the agreement to be penalized\n     * @param rewardAccount Account that collect the reward\n     * @param rewardAmount Amount of liquidation reward\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     */\n    event AgreementLiquidated(\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed penaltyAccount,\n        address indexed rewardAccount,\n        uint256 rewardAmount\n    );\n\n    /**\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\n     * @param bailoutAccount Account that bailout the penalty account\n     * @param bailoutAmount Amount of account bailout\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     */\n    event Bailout(\n        address indexed bailoutAccount,\n        uint256 bailoutAmount\n    );\n\n    /**\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param penaltyAccount Account of the agreement to be penalized\n     * @param bondAccount Account that collect the reward or bailout accounts\n     * @param rewardAmount Amount of liquidation reward\n     * @param bailoutAmount Amount of liquidation bailouot\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     *\n     * @custom:note \n     * Reward account rule:\n     * - if bailout is equal to 0, then\n     *   - the bondAccount will get the rewardAmount,\n     *   - the penaltyAccount will pay for the rewardAmount.\n     * - if bailout is larger than 0, then\n     *   - the liquidatorAccount will get the rewardAmouont,\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\n     */\n    event AgreementLiquidatedBy(\n        address liquidatorAccount,\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed penaltyAccount,\n        address indexed bondAccount,\n        uint256 rewardAmount,\n        uint256 bailoutAmount\n    );\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluid } from \"./ISuperfluid.sol\";\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\nimport { TokenInfo } from \"../tokens/TokenInfo.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IConstantOutflowNFT } from \"./IConstantOutflowNFT.sol\";\nimport { IConstantInflowNFT } from \"./IConstantInflowNFT.sol\";\nimport { IPoolAdminNFT } from \"./IPoolAdminNFT.sol\";\nimport { IPoolMemberNFT } from \"./IPoolMemberNFT.sol\";\n\n/**\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\n * @author Superfluid\n */\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\n    error SUPER_TOKEN_ONLY_GOV_OWNER();                          // 0xd9c7ed08\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\n    error SUPER_TOKEN_NFT_PROXY_ADDRESS_CHANGED();               // 0x6bef249d\n\n    /**\n     * @dev Initialize the contract\n     */\n    function initialize(\n        IERC20 underlyingToken,\n        uint8 underlyingDecimals,\n        string calldata n,\n        string calldata s\n    ) external;\n\n    /**************************************************************************\n    * Immutable variables\n    *************************************************************************/\n    function CONSTANT_OUTFLOW_NFT() external view returns (IConstantOutflowNFT);\n    function CONSTANT_INFLOW_NFT() external view returns (IConstantInflowNFT);\n\n    /**************************************************************************\n    * TokenInfo & ERC777\n    *************************************************************************/\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * @custom:note SuperToken always uses 18 decimals.\n     *\n     * This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view override(TokenInfo) returns (uint8);\n\n    /**************************************************************************\n    * ERC20 & ERC777\n    *************************************************************************/\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\n\n    /**************************************************************************\n    * ERC20\n    *************************************************************************/\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\n     *         zero by default.\n     *\n     * @notice This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:note Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * @custom:emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     *         allowance mechanism. `amount` is then deducted from the caller's\n     *         allowance.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * @custom:emits an {Approval} event indicating the updated allowance.\n     *\n     * @custom:requirements \n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * @custom:emits an {Approval} event indicating the updated allowance.\n     *\n     * @custom:requirements \n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**************************************************************************\n    * ERC777\n    *************************************************************************/\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     *         means all token operations (creation, movement and destruction) must have\n     *         amounts that are a multiple of this number.\n     *\n     * @custom:note For super token contracts, this value is always 1\n     */\n    function granularity() external view override(IERC777) returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\n     *      the corresponding functions will be called with `data` and empty\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * @custom:emits a {Sent} event.\n     *\n     * @custom:requirements \n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply and transfers the underlying token to the caller's account.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * @custom:emits a {Burned} event.\n     *\n     * @custom:requirements \n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * @custom:emits an {AuthorizedOperator} event.\n     *\n     * @custom:requirements \n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external override(IERC777);\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * @custom:emits a {RevokedOperator} event.\n     *\n     * @custom:requirements \n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external override(IERC777);\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * @custom:emits a {Sent} event.\n     *\n     * @custom:requirements \n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external override(IERC777);\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * @custom:emits a {Burned} event.\n     *\n     * @custom:requirements \n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external override(IERC777);\n\n    /**************************************************************************\n     * SuperToken custom token functions\n     *************************************************************************/\n\n    /**\n     * @dev Mint new tokens for the account\n     *\n     * @custom:modifiers \n     *  - onlySelf\n     */\n    function selfMint(\n        address account,\n        uint256 amount,\n        bytes memory userData\n    ) external;\n\n   /**\n    * @dev Burn existing tokens for the account\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfBurn(\n       address account,\n       uint256 amount,\n       bytes memory userData\n   ) external;\n\n   /**\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\n    * spend tokens of `sender`.\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfTransferFrom(\n        address sender,\n        address spender,\n        address recipient,\n        uint256 amount\n   ) external;\n\n   /**\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\n    * `account`.\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfApproveFor(\n        address account,\n        address spender,\n        uint256 amount\n   ) external;\n\n    /**************************************************************************\n     * SuperToken extra functions\n     *************************************************************************/\n\n    /**\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\n     */\n    function transferAll(address recipient) external;\n\n    /**************************************************************************\n     * ERC20 wrapping\n     *************************************************************************/\n\n    /**\n     * @dev Return the underlying token contract\n     * @return tokenAddr Underlying token address\n     */\n    function getUnderlyingToken() external view returns(address tokenAddr);\n\n    /**\n     * @dev Upgrade ERC20 to SuperToken.\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\n     *\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\n     * function you should `approve` this contract\n     */\n    function upgrade(uint256 amount) external;\n\n    /**\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\n     * @param to The account to receive upgraded tokens\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\n     * @param data User data for the TokensRecipient callback\n     *\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\n     * function you should `approve` this contract\n     * \n     * @custom:warning\n     * - there is potential of reentrancy IF the \"to\" account is a registered ERC777 recipient.\n     * @custom:requirements \n     * - if `data` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient otherwise it reverts.\n     */\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Token upgrade event\n     * @param account Account where tokens are upgraded to\n     * @param amount Amount of tokens upgraded (in 18 decimals)\n     */\n    event TokenUpgraded(\n        address indexed account,\n        uint256 amount\n    );\n\n    /**\n     * @dev Downgrade SuperToken to ERC20.\n     * @dev It will call transfer to send tokens\n     * @param amount Number of tokens to be downgraded\n     */\n    function downgrade(uint256 amount) external;\n\n    /**\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\n     * @param to The account to receive downgraded tokens\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\n     */\n    function downgradeTo(address to, uint256 amount) external;\n\n    /**\n     * @dev Token downgrade event\n     * @param account Account whose tokens are downgraded\n     * @param amount Amount of tokens downgraded\n     */\n    event TokenDowngraded(\n        address indexed account,\n        uint256 amount\n    );\n\n    /**************************************************************************\n    * Batch Operations\n    *************************************************************************/\n\n    /**\n    * @dev Perform ERC20 approve by host contract.\n    * @param account The account owner to be approved.\n    * @param spender The spender of account owner's funds.\n    * @param amount Number of tokens to be approved.\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationApprove(\n        address account,\n        address spender,\n        uint256 amount\n    ) external;\n\n    function operationIncreaseAllowance(\n        address account,\n        address spender,\n        uint256 addedValue\n    ) external;\n\n    function operationDecreaseAllowance(\n        address account,\n        address spender,\n        uint256 subtractedValue\n    ) external;\n\n    /**\n    * @dev Perform ERC20 transferFrom by host contract.\n    * @param account The account to spend sender's funds.\n    * @param spender The account where the funds is sent from.\n    * @param recipient The recipient of the funds.\n    * @param amount Number of tokens to be transferred.\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationTransferFrom(\n        address account,\n        address spender,\n        address recipient,\n        uint256 amount\n    ) external;\n\n    /**\n    * @dev Perform ERC777 send by host contract.\n    * @param spender The account where the funds is sent from.\n    * @param recipient The recipient of the funds.\n    * @param amount Number of tokens to be transferred.\n    * @param data Arbitrary user inputted data\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationSend(\n        address spender,\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    /**\n    * @dev Upgrade ERC20 to SuperToken by host contract.\n    * @param account The account to be changed.\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationUpgrade(address account, uint256 amount) external;\n\n    /**\n    * @dev Downgrade ERC20 to SuperToken by host contract.\n    * @param account The account to be changed.\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationDowngrade(address account, uint256 amount) external;\n\n    // Flow NFT events\n    /**\n     * @dev Constant Outflow NFT proxy created event\n     * @param constantOutflowNFT constant outflow nft address\n     */\n    event ConstantOutflowNFTCreated(\n        IConstantOutflowNFT indexed constantOutflowNFT\n    );\n\n    /**\n     * @dev Constant Inflow NFT proxy created event\n     * @param constantInflowNFT constant inflow nft address\n     */\n    event ConstantInflowNFTCreated(\n        IConstantInflowNFT indexed constantInflowNFT\n    );\n\n    /**************************************************************************\n    * Function modifiers for access control and parameter validations\n    *\n    * While they cannot be explicitly stated in function definitions, they are\n    * listed in function definition comments instead for clarity.\n    *\n    * NOTE: solidity-coverage not supporting it\n    *************************************************************************/\n\n    /// @dev The msg.sender must be the contract itself\n    //modifier onlySelf() virtual\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperToken } from \"./ISuperToken.sol\";\n\nimport {\n    IERC20,\n    ERC20WithTokenInfo\n} from \"../tokens/ERC20WithTokenInfo.sol\";\n\n/**\n * @title Super token factory interface\n * @author Superfluid\n */\ninterface ISuperTokenFactory {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS();                 // 0x91d67972\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST();                 // 0x872cac48\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();                  // 0x1b39b9b4\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();                      // 0x478b8e83\n    error SUPER_TOKEN_FACTORY_NON_UPGRADEABLE_IS_DEPRECATED();  // 0x478b8e83\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();                   // 0x305c9e82\n\n    /**************************************************************************\n    * Immutable Variables\n    **************************************************************************/\n\n    /**\n     * @dev Get superfluid host contract address\n     */\n    function getHost() external view returns(address host);\n\n    /// @dev Initialize the contract\n    function initialize() external;\n\n    /**\n     * @notice Get the canonical super token logic.\n     */\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\n\n    /**\n     * @dev Upgradability modes\n     */\n    enum Upgradability {\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\n        NON_UPGRADABLE,\n        /// Upgradable through `host.updateSuperTokenLogic` operation\n        SEMI_UPGRADABLE,\n        /// Always using the latest super token logic\n        FULL_UPGRADABLE\n    }\n\n    /**\n     * @notice Create new super token wrapper for the underlying ERC20 token\n     * @param underlyingToken Underlying ERC20 token\n     * @param underlyingDecimals Underlying token decimals\n     * @param upgradability Upgradability mode\n     * @param name Super token name\n     * @param symbol Super token symbol\n     * @return superToken The deployed and initialized wrapper super token\n     */\n    function createERC20Wrapper(\n        IERC20 underlyingToken,\n        uint8 underlyingDecimals,\n        Upgradability upgradability,\n        string calldata name,\n        string calldata symbol\n    )\n        external\n        returns (ISuperToken superToken);\n\n    /**\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\n     * @param underlyingToken Underlying ERC20 token\n     * @param upgradability Upgradability mode\n     * @param name Super token name\n     * @param symbol Super token symbol\n     * @return superToken The deployed and initialized wrapper super token\n     * NOTE:\n     * - It assumes token provide the .decimals() function\n     */\n    function createERC20Wrapper(\n        ERC20WithTokenInfo underlyingToken,\n        Upgradability upgradability,\n        string calldata name,\n        string calldata symbol\n    )\n        external\n        returns (ISuperToken superToken);\n\n    /**\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\n     * @param _underlyingToken Underlying ERC20 token\n     * @return ISuperToken the created supertoken\n     */\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\n        external\n        returns (ISuperToken);\n\n    /**\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\n     * @param _underlyingToken Underlying ERC20 token address\n     * @return superTokenAddress Super token address\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\n     */\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\n        external\n        view\n        returns (address superTokenAddress, bool isDeployed);\n\n    /**\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\n     * @dev We return the address if it exists and the zero address otherwise\n     * @param _underlyingTokenAddress Underlying ERC20 token address\n     * @return superTokenAddress Super token address\n     */\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\n        external\n        view\n        returns (address superTokenAddress);\n\n    /**\n     * @dev Creates a new custom super token\n     * @param customSuperTokenProxy address of the custom supertoken proxy\n     */\n    function initializeCustomSuperToken(\n        address customSuperTokenProxy\n    )\n        external;\n\n    /**\n      * @dev Super token logic created event\n      * @param tokenLogic Token logic address\n      */\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\n\n    /**\n      * @dev Super token created event\n      * @param token Newly created super token address\n      */\n    event SuperTokenCreated(ISuperToken indexed token);\n\n    /**\n      * @dev Custom super token created event\n      * @param token Newly created custom super token address\n      */\n    event CustomSuperTokenCreated(ISuperToken indexed token);\n\n}"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TokenInfo } from \"./TokenInfo.sol\";\n\n/**\n * @title ERC20 token with token info interface\n * @author Superfluid\n * @dev Using abstract contract instead of interfaces because old solidity\n *      does not support interface inheriting other interfaces\n * solhint-disable-next-line no-empty-blocks\n *\n */\n// solhint-disable-next-line no-empty-blocks\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperToken } from \"../superfluid/ISuperToken.sol\";\n\n\n/**\n * @title Super ETH (SETH) custom token interface\n * @author Superfluid\n */\ninterface ISETHCustom {\n    // using native token\n    function upgradeByETH() external payable;\n    function upgradeByETHTo(address to) external payable;\n    function downgradeToETH(uint wad) external;\n}\n\n/**\n * @title Super ETH (SETH) full interface\n * @author Superfluid\n */\n// solhint-disable-next-line no-empty-blocks\ninterface ISETH is ISETHCustom, ISuperToken {}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\n/**\n * @title ERC20 token info interface\n * @author Superfluid\n * @dev ERC20 standard interface does not specify these functions, but\n *      often the token implementations have them.\n */\ninterface TokenInfo {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/allowlist/AllowlistReadableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\nimport { AllowlistStorage } from './AllowlistStorage.sol';\n\n/**\n * @title AllowlistReadableInternal\n */\nabstract contract AllowlistReadableInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Check if address is allowed\n     */\n    function _isAllowed(address _address) internal view returns (bool) {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        if (l.allowAny) {\n            return true;\n        }\n        return l.allowlist.contains(_address);\n    }\n}\n"
    },
    "contracts/allowlist/AllowlistStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\n\n/**\n * @title AllowlistStorage\n */\nlibrary AllowlistStorage {\n    struct Layout {\n        bool isInitialized;\n        bool allowAny;\n        EnumerableSet.AddressSet allowlist;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.AllowlistStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/allowlist/AllowlistWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\nimport { AllowlistStorage } from './AllowlistStorage.sol';\nimport { IAllowlistWritableInternal } from './IAllowlistWritableInternal.sol';\n\n/**\n * @title AllowlistWritableInternal\n */\nabstract contract AllowlistWritableInternal is IAllowlistWritableInternal {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @notice Initialize allowlist\n     */\n    function _initializeAllowlist(\n        bool _allowAny,\n        address[] memory _addresses\n    ) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        l.isInitialized = true;\n\n        _setAllowAny(_allowAny);\n\n        for (uint256 i; i < _addresses.length; i++) {\n            l.allowlist.add(_addresses[i]);\n        }\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return AllowlistStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Set allow any\n     */\n    function _setAllowAny(bool _allowAny) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        l.allowAny = _allowAny;\n\n        emit AllowAnyUpdated(_allowAny);\n    }\n\n    /**\n     * @notice Add to allowlist\n     */\n    function _addToAllowlist(address _address) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        l.allowlist.add(_address);\n\n        emit Allowlisted(_address);\n    }\n\n    /**\n     * @notice Remove from allowlist\n     */\n    function _removeFromAllowlist(address _address) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        l.allowlist.remove(_address);\n\n        emit Unallowlisted(_address);\n    }\n\n    /**\n     * @notice Batch add to allowlist\n     */\n    function _batchAddToAllowlist(address[] memory _addresses) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        for (uint256 i; i < _addresses.length; i++) {\n            l.allowlist.add(_addresses[i]);\n        }\n\n        emit BatchAllowlisted(_addresses);\n    }\n\n    /**\n     * @notice Batch remove from allowlist\n     */\n    function _batchRemoveFromAllowlist(address[] memory _addresses) internal {\n        AllowlistStorage.Layout storage l = AllowlistStorage.layout();\n\n        for (uint256 i; i < _addresses.length; i++) {\n            l.allowlist.remove(_addresses[i]);\n        }\n\n        emit BatchUnallowlisted(_addresses);\n    }\n}\n"
    },
    "contracts/allowlist/facets/AllowlistFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnumerableSet } from '@solidstate/contracts/data/EnumerableSet.sol';\nimport { IAllowlistWritable } from '../IAllowlistWritable.sol';\nimport { AllowlistStorage } from '../AllowlistStorage.sol';\nimport { AllowlistReadableInternal } from '../AllowlistReadableInternal.sol';\nimport { AllowlistWritableInternal } from '../AllowlistWritableInternal.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\nimport { IAllowlistReadable } from '../IAllowlistReadable.sol';\n\n/**\n * @title AllowlistFacet\n * @dev Allows owner to set an allowlist of addresses\n */\ncontract AllowlistFacet is\n    AccessControlInternal,\n    IAllowlistWritable,\n    IAllowlistReadable,\n    AllowlistReadableInternal,\n    AllowlistWritableInternal,\n    ERC165BaseInternal\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('AllowlistFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize allowlist\n     */\n    function initializeAllowlist(\n        bool allowAny,\n        address[] memory _addresses\n    ) external {\n        require(\n            _isInitialized() == false,\n            'AllowlistFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IAllowlistReadable).interfaceId, true);\n        _initializeAllowlist(allowAny, _addresses);\n    }\n\n    /**\n     * @notice Initialize allowlist with owner\n     */\n    function initializeAllowlist(\n        address _owner,\n        bool allowAny,\n        address[] memory _addresses\n    ) external {\n        require(\n            _isInitialized() == false,\n            'AllowlistFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IAllowlistReadable).interfaceId, true);\n        _setSupportsInterface(type(IAllowlistWritable).interfaceId, true);\n        _grantRole(COMPONENT_ROLE, _owner);\n        _initializeAllowlist(allowAny, _addresses);\n    }\n\n    /**\n     * @notice Check if address is allowed\n     */\n    function isAllowed(address _address) external view returns (bool) {\n        return _isAllowed(_address);\n    }\n\n    /**\n     * @notice Set allow any\n     */\n    function setAllowAny(bool _allowAny) external onlyRole(COMPONENT_ROLE) {\n        return _setAllowAny(_allowAny);\n    }\n\n    /**\n     * @notice Add to allowlist\n     */\n    function addToAllowlist(\n        address _address\n    ) external onlyRole(COMPONENT_ROLE) {\n        _addToAllowlist(_address);\n    }\n\n    /**\n     * @notice Remove from allowlist\n     */\n    function removeFromAllowlist(\n        address _address\n    ) external onlyRole(COMPONENT_ROLE) {\n        _removeFromAllowlist(_address);\n    }\n\n    /**\n     * @notice Batch add to allowlist\n     */\n    function batchAddToAllowlist(\n        address[] memory _addresses\n    ) external onlyRole(COMPONENT_ROLE) {\n        _batchAddToAllowlist(_addresses);\n    }\n\n    /**\n     * @notice Batch remove from allowlist\n     */\n    function batchRemoveFromAllowlist(\n        address[] memory _addresses\n    ) external onlyRole(COMPONENT_ROLE) {\n        _batchRemoveFromAllowlist(_addresses);\n    }\n}\n"
    },
    "contracts/allowlist/facets/AllowlistMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IAllowlistReadable } from '../IAllowlistReadable.sol';\n\ncontract AllowlistMock is IAllowlistReadable {\n    struct Layout {\n        bool isAllowed;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.MockAllowlist');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    /**\n     * @notice Check if address is allowed\n     */\n    function isAllowed(address) external view returns (bool) {\n        return layout().isAllowed;\n    }\n\n    function setIsAllowed(bool _isAllowed) external {\n        layout().isAllowed = _isAllowed;\n    }\n}\n"
    },
    "contracts/allowlist/IAllowlistReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IAllowlistReadable\n */\ninterface IAllowlistReadable {\n    /**\n     * @notice Check if address is allowed\n     */\n    function isAllowed(address _address) external view returns (bool);\n}\n"
    },
    "contracts/allowlist/IAllowlistWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IAllowlistWritable\n */\ninterface IAllowlistWritable {\n    /**\n     * @notice Set allow any\n     */\n    function setAllowAny(bool _allowAny) external;\n\n    /**\n     * @notice Add to allowlist\n     */\n    function addToAllowlist(address _address) external;\n\n    /**\n     * @notice Remove from allowlist\n     */\n    function removeFromAllowlist(address _address) external;\n}\n"
    },
    "contracts/allowlist/IAllowlistWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IAllowlistWritableInternal\n */\ninterface IAllowlistWritableInternal {\n    event Allowlisted(address indexed _address);\n    event BatchAllowlisted(address[] _addresses);\n\n    event Unallowlisted(address indexed _address);\n    event BatchUnallowlisted(address[] _addresses);\n\n    event AllowAnyUpdated(bool indexed _allowAny);\n}\n"
    },
    "contracts/auction/EnglishPeriodicAuctionInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 maxTokenCount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.maxTokenCount = maxTokenCount;\n        l.initialBidder = initialBidder;\n        l.startingBid = startingBid;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function _maxTokenCount() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().maxTokenCount;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(uint256 tokenId) internal view returns (Bid storage) {\n        return EnglishPeriodicAuctionStorage.layout().highestBids[tokenId];\n    }\n\n    /**\n     * @notice Get current bid\n     */\n    function _currentBid(uint256 tokenId) internal view returns (Bid storage) {\n        return EnglishPeriodicAuctionStorage.layout().currentBids[tokenId];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return EnglishPeriodicAuctionStorage.layout().bids[tokenId][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= _maxTokenCount()) {\n            return false;\n        }\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= _maxTokenCount()) {\n            return false;\n        }\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        Bid storage bid = l.bids[tokenId][bidder];\n\n        if (l.highestBids[tokenId].round == l.currentAuctionRound[tokenId]) {\n            // Check if highest bid\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId].bidAmount + l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount;\n        if (bid.round == l.currentAuctionRound[tokenId]) {\n            // If bidder has bid for round, add to existing bid\n            totalCollateralAmount = bid.collateralAmount + collateralAmount;\n        } else {\n            totalCollateralAmount = collateralAmount;\n        }\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.round = l.currentAuctionRound[tokenId];\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId] = bid;\n\n        emit BidPlaced(tokenId, bid.round, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n    }\n\n    /**\n     * @notice Withdraw bid collateral if not highest bidder\n     */\n    function _withdrawBid(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId].bidder,\n            'EnglishPeriodicAuction: Cannot withdraw bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No collateral to withdraw'\n        );\n\n        // Reset collateral and bid\n        uint256 collateralAmount = bid.collateralAmount;\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n\n        // Transfer collateral back to bidder\n        (bool success, ) = bidder.call{ value: collateralAmount }('');\n        require(\n            success,\n            'EnglishPeriodicAuction: Failed to withdraw collateral'\n        );\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function _closeAuction(uint256 tokenId) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address oldBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            oldBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            oldBidder = l.initialBidder;\n        }\n\n        // Set lastPeriodEndTime to the end of the current auction period\n        l.lastPeriodEndTime[tokenId] = block.timestamp;\n\n        if (l.highestBids[tokenId].bidder == address(0)) {\n            // No bids were placed, transfer to reposssessor\n            Bid storage repossessorBid = l.bids[tokenId][l.repossessor];\n            repossessorBid.round = l.currentAuctionRound[tokenId];\n            repossessorBid.bidAmount = 0;\n            repossessorBid.collateralAmount = 0;\n            repossessorBid.feeAmount = 0;\n            repossessorBid.bidder = l.repossessor;\n\n            l.highestBids[tokenId] = repossessorBid;\n        } else {\n            // Transfer bid to previous bidder's collateral\n            l.bids[tokenId][oldBidder].collateralAmount += l\n                .highestBids[tokenId]\n                .bidAmount;\n        }\n\n        emit AuctionClosed(\n            tokenId,\n            l.currentAuctionRound[tokenId],\n            l.highestBids[tokenId].bidder,\n            oldBidder,\n            l.highestBids[tokenId].bidAmount\n        );\n\n        // Reset auction\n        l.currentBids[tokenId] = l.highestBids[tokenId];\n        l.bids[tokenId][l.highestBids[tokenId].bidder].collateralAmount = 0;\n        l.currentBids[tokenId].collateralAmount = 0;\n        l.currentAuctionLength[tokenId] = l.auctionLengthSeconds;\n        l.currentAuctionRound[tokenId] = l.currentAuctionRound[tokenId] + 1;\n\n        // Transfer to highest bidder\n        IStewardLicense(address(this)).triggerTransfer(\n            oldBidder,\n            l.highestBids[tokenId].bidder,\n            tokenId\n        );\n\n        // Distribute fee to beneficiary\n        if (l.highestBids[tokenId].feeAmount > 0) {\n            IBeneficiary(address(this)).distribute{\n                value: l.highestBids[tokenId].feeAmount\n            }();\n        }\n    }\n\n    /**\n     * @notice Mint token if it doesn't exist\n     */\n    function _mintToken(address to, uint256 tokenId) internal {\n        require(\n            IStewardLicense(address(this)).exists(tokenId) == false,\n            'EnglishPeriodicAuction: Token already exists'\n        );\n\n        IStewardLicense(address(this)).triggerTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function _auctionStartTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionStartTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 licensePeriod = IPeriodicPCOParamsReadable(address(this))\n            .licensePeriod();\n\n        if (l.lastPeriodEndTime[tokenId] > l.initialPeriodStartTime) {\n            // Auction starts after licensePeriod has elapsed\n            auctionStartTime = l.lastPeriodEndTime[tokenId] + licensePeriod;\n        } else {\n            // Auction starts at initial time\n            auctionStartTime =\n                l.initialPeriodStartTime +\n                (tokenId * l.initialPeriodStartTimeOffset);\n        }\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function _auctionEndTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionEndTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 auctionLengthSeconds;\n        if (l.currentAuctionLength[tokenId] == 0) {\n            auctionLengthSeconds = _auctionLengthSeconds();\n        } else {\n            auctionLengthSeconds = l.currentAuctionLength[tokenId];\n        }\n\n        auctionEndTime = _auctionStartTime(tokenId) + auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function _calculateFeeFromBid(\n        uint256 bidAmount\n    ) internal view returns (uint256) {\n        uint256 feeNumerator = IPeriodicPCOParamsReadable(address(this))\n            .feeNumerator();\n        uint256 feeDenominator = IPeriodicPCOParamsReadable(address(this))\n            .feeDenominator();\n\n        return (bidAmount * feeNumerator) / feeDenominator;\n    }\n\n    /**\n     * @notice Check that fee is within rounding error of bid amount\n     */\n    function _checkBidAmount(\n        uint256 bidAmount,\n        uint256 feeAmount\n    ) internal view returns (bool) {\n        uint256 calculatedFeeAmount = _calculateFeeFromBid(bidAmount);\n\n        return calculatedFeeAmount == feeAmount;\n    }\n}\n"
    },
    "contracts/auction/EnglishPeriodicAuctionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\nlibrary EnglishPeriodicAuctionStorage {\n    struct Layout {\n        bool isInitialized;\n        // Same for all tokens\n        address initialBidder;\n        uint256 startingBid;\n        address repossessor;\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        uint256 auctionLengthSeconds;\n        uint256 minBidIncrement;\n        uint256 bidExtensionWindowLengthSeconds;\n        uint256 bidExtensionSeconds;\n        uint256 maxTokenCount;\n        // Per token config\n        mapping(uint256 => uint256) lastPeriodEndTime;\n        mapping(uint256 => uint256) currentAuctionRound;\n        mapping(uint256 => uint256) currentAuctionLength;\n        mapping(uint256 => mapping(address => IEnglishPeriodicAuctionInternal.Bid)) bids;\n        mapping(uint256 => IEnglishPeriodicAuctionInternal.Bid) currentBids;\n        mapping(uint256 => IEnglishPeriodicAuctionInternal.Bid) highestBids;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.EnglishPeriodicAuctionStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/auction/facets/EnglishPeriodicAuctionFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionInternal } from '../EnglishPeriodicAuctionInternal.sol';\nimport { IPeriodicAuctionReadable } from '../IPeriodicAuctionReadable.sol';\nimport { IPeriodicAuctionWritable } from '../IPeriodicAuctionWritable.sol';\nimport { IAllowlistReadable } from '../../allowlist/IAllowlistReadable.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionFacet\n */\ncontract EnglishPeriodicAuctionFacet is\n    IPeriodicAuctionReadable,\n    IPeriodicAuctionWritable,\n    EnglishPeriodicAuctionInternal,\n    AccessControlInternal,\n    ERC165BaseInternal\n{\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('EnglishPeriodicAuctionFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize auction parameters\n     */\n    function initializeAuction(\n        address _repossessor,\n        address initialBidder,\n        uint256 _initialPeriodStartTime,\n        uint256 _initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 _auctionLengthSeconds,\n        uint256 _minBidIncrement,\n        uint256 _bidExtensionWindowLengthSeconds,\n        uint256 _bidExtensionSeconds,\n        uint256 _maxTokenCount\n    ) external {\n        require(\n            _isInitialized() == false,\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _initializeAuction(\n            _repossessor,\n            initialBidder,\n            _initialPeriodStartTime,\n            _initialPeriodStartTimeOffset,\n            startingBid,\n            _auctionLengthSeconds,\n            _minBidIncrement,\n            _bidExtensionWindowLengthSeconds,\n            _bidExtensionSeconds,\n            _maxTokenCount\n        );\n    }\n\n    /**\n     * @notice Initialize auction parameters with owner\n     */\n    function initializeAuction(\n        address _owner,\n        address _repossessor,\n        address initialBidder,\n        uint256 _initialPeriodStartTime,\n        uint256 _initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 _auctionLengthSeconds,\n        uint256 _minBidIncrement,\n        uint256 _bidExtensionWindowLengthSeconds,\n        uint256 _bidExtensionSeconds,\n        uint256 _maxTokenCount\n    ) external {\n        require(\n            _isInitialized() == false,\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _setSupportsInterface(type(IPeriodicAuctionWritable).interfaceId, true);\n        _grantRole(COMPONENT_ROLE, _owner);\n        _initializeAuction(\n            _repossessor,\n            initialBidder,\n            _initialPeriodStartTime,\n            _initialPeriodStartTimeOffset,\n            startingBid,\n            _auctionLengthSeconds,\n            _minBidIncrement,\n            _bidExtensionWindowLengthSeconds,\n            _bidExtensionSeconds,\n            _maxTokenCount\n        );\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function setAuctionParameters(\n        address _repossessor,\n        uint256 _auctionLengthSeconds,\n        uint256 _minBidIncrement,\n        uint256 _bidExtensionWindowLengthSeconds,\n        uint256 _bidExtensionSeconds\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionParameters(\n            _repossessor,\n            _auctionLengthSeconds,\n            _minBidIncrement,\n            _bidExtensionWindowLengthSeconds,\n            _bidExtensionSeconds\n        );\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function maxTokenCount() external view returns (uint256) {\n        return _maxTokenCount();\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function isAuctionPeriod(uint256 tokenId) external view returns (bool) {\n        return _isAuctionPeriod(tokenId);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function initialPeriodStartTime() external view returns (uint256) {\n        return _initialPeriodStartTime();\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function isReadyForTransfer(uint256 tokenId) external view returns (bool) {\n        return _isReadyForTransfer(tokenId);\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function placeBid(uint256 tokenId, uint256 bidAmount) external payable {\n        require(\n            _isAuctionPeriod(tokenId),\n            'EnglishPeriodicAuction: can only place bid in auction period'\n        );\n        require(\n            _isReadyForTransfer(tokenId) == false,\n            'EnglishPeriodicAuction: auction is over and awaiting transfer'\n        );\n        require(\n            IAllowlistReadable(address(this)).isAllowed(msg.sender),\n            'EnglishPeriodicAuction: sender is not allowed to place bid'\n        );\n\n        _placeBid(tokenId, msg.sender, bidAmount, msg.value);\n    }\n\n    /**\n     * @notice Withdraw bid collateral\n     */\n    function withdrawBid(uint256 tokenId) external {\n        _withdrawBid(tokenId, msg.sender);\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function closeAuction(uint256 tokenId) external {\n        require(\n            _isReadyForTransfer(tokenId),\n            'EnglishPeriodicAuction: auction is not over'\n        );\n\n        _closeAuction(tokenId);\n    }\n\n    /**\n     * @notice Initial bidder can mint token if it doesn't exist\n     */\n    function mintToken(address to, uint256 tokenId) external {\n        require(\n            msg.sender == _initialBidder(),\n            'EnglishPeriodicAuction: only initial bidder can mint token'\n        );\n        require(\n            block.timestamp < _initialPeriodStartTime(),\n            'EnglishPeriodicAuction: cannot mint after initial period start time'\n        );\n\n        _mintToken(to, tokenId);\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function calculateFeeFromBid(\n        uint256 bidAmount\n    ) external view returns (uint256) {\n        return _calculateFeeFromBid(bidAmount);\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function auctionStartTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function auctionEndTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function repossessor() external view returns (address) {\n        return _repossessor();\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function setRepossessor(\n        address _repossessor\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setRepossessor(_repossessor);\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function auctionLengthSeconds() external view returns (uint256) {\n        return _auctionLengthSeconds();\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function setAuctionLengthSeconds(\n        uint256 _auctionLengthSeconds\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionLengthSeconds(_auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function minBidIncrement() external view returns (uint256) {\n        return _minBidIncrement();\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function setMinBidIncrement(\n        uint256 _minBidIncrement\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setMinBidIncrement(_minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function bidExtensionWindowLengthSeconds() external view returns (uint256) {\n        return _bidExtensionWindowLengthSeconds();\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function setBidExtensionWindowLengthSeconds(\n        uint256 _bidExtensionWindowLengthSeconds\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionWindowLengthSeconds(_bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     *  @notice Get bid extension seconds\n     */\n    function bidExtensionSeconds() external view returns (uint256) {\n        return _bidExtensionSeconds();\n    }\n\n    /**\n     *  @notice Set bid extension seconds\n     */\n    function setBidExtensionSeconds(\n        uint256 _bidExtensionSeconds\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionSeconds(_bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function highestBid(uint256 tokenId) external view returns (Bid memory) {\n        return _highestBid(tokenId);\n    }\n\n    /**\n     * @notice Get current bid\n     */\n    function currentBid(uint256 tokenId) external view returns (Bid memory) {\n        return _currentBid(tokenId);\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function bidOf(\n        uint256 tokenId,\n        address bidder\n    ) external view returns (Bid memory) {\n        return _bidOf(tokenId, bidder);\n    }\n}\n"
    },
    "contracts/auction/facets/PeriodicAuctionMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IPeriodicAuctionReadable } from '../IPeriodicAuctionReadable.sol';\n\ncontract PeriodicAuctionMock is IPeriodicAuctionReadable {\n    struct Layout {\n        bool isAuctionPeriod;\n        bool shouldFail;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.PeriodicAuctionMock');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isAuctionPeriod(uint256) external view returns (bool) {\n        require(!layout().shouldFail, 'PeriodicAuctionMock: failed');\n        return layout().isAuctionPeriod;\n    }\n\n    function setIsAuctionPeriod(bool _isAuctionPeriod) external {\n        layout().isAuctionPeriod = _isAuctionPeriod;\n    }\n\n    function setShouldFail(bool _shouldFail) external {\n        layout().shouldFail = _shouldFail;\n    }\n}\n"
    },
    "contracts/auction/IEnglishPeriodicAuctionInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IEnglishPeriodicAuctionInternal\n */\ninterface IEnglishPeriodicAuctionInternal {\n    struct Bid {\n        uint256 round;\n        address bidder;\n        uint256 bidAmount;\n        uint256 feeAmount;\n        uint256 collateralAmount;\n    }\n\n    event InitialPeriodStartTimeSet(uint256 initialPeriodStartTime);\n    event RepossessorSet(address repossessor);\n    event AuctionLengthSet(uint256 auctionLengthSeconds);\n    event MinBidIncrementSet(uint256 minBidIncrement);\n    event BidExtensionWindowLengthSet(uint256 bidExtensionWindowLengthSeconds);\n    event BidExtensionSet(uint256 bidExtensionSeconds);\n\n    event BidPlaced(\n        uint256 indexed tokenId,\n        uint256 indexed round,\n        address indexed bidder,\n        uint256 bidAmount\n    );\n    event AuctionClosed(\n        uint256 indexed tokenId,\n        uint256 indexed round,\n        address indexed winningBidder,\n        address previousOwner,\n        uint256 bidAmount\n    );\n}\n"
    },
    "contracts/auction/IPeriodicAuctionReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicAuctionReadable\n */\ninterface IPeriodicAuctionReadable {\n    /**\n     * @notice Get is auction period\n     */\n    function isAuctionPeriod(uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/auction/IPeriodicAuctionWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicAuctionWritable\n */\ninterface IPeriodicAuctionWritable {\n    /**\n     * @notice Set repossessor\n     */\n    function setRepossessor(address _repossessor) external;\n\n    /**\n     * @notice Set auction length\n     */\n    function setAuctionLengthSeconds(uint256 _auctionLengthSeconds) external;\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function setMinBidIncrement(uint256 _minBidIncrement) external;\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function setBidExtensionWindowLengthSeconds(\n        uint256 _bidExtensionWindowLengthSeconds\n    ) external;\n\n    /**\n     *  @notice Set bid extension seconds\n     */\n    function setBidExtensionSeconds(uint256 _bidExtensionSeconds) external;\n}\n"
    },
    "contracts/auction/mocks/MockBidder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionFacet } from '../facets/EnglishPeriodicAuctionFacet.sol';\n\ncontract MockBidder {\n    EnglishPeriodicAuctionFacet public auction;\n\n    constructor(EnglishPeriodicAuctionFacet _auction) {\n        auction = _auction;\n    }\n\n    // Withdraw bid\n    function withdrawBid(uint256 tokenId) external {\n        auction.withdrawBid(tokenId);\n    }\n\n    // Fail on receive\n    receive() external payable {\n        revert('MockBidder: receive not allowed');\n    }\n}\n"
    },
    "contracts/beneficiary/facets/BeneficiaryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IBeneficiary } from '../IBeneficiary.sol';\nimport { OwnableInternal } from '@solidstate/contracts/access/ownable/OwnableInternal.sol';\n\ncontract BeneficiaryMock is IBeneficiary, OwnableInternal {\n    /**\n     * @notice Initialize beneficiary\n     */\n    function initializeMockBeneficiary(address _owner) external {\n        _setOwner(_owner);\n    }\n\n    /**\n     * @notice Distribute to beneficiaries\n     */\n    function distribute() external payable {\n        (bool success, ) = _owner().call{ value: msg.value }('');\n    }\n}\n"
    },
    "contracts/beneficiary/facets/IDABeneficiaryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\nimport { SuperTokenV1Library } from '@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol';\nimport { IIDABeneficiary } from '../IIDABeneficiary.sol';\nimport { IDABeneficiaryInternal } from '../IDABeneficiaryInternal.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\nimport { IBeneficiary } from '../IBeneficiary.sol';\n\n/**\n * @title IDABeneficiaryFacet\n * @dev Beneficiary implemented using a Superfluid IDA index\n */\ncontract IDABeneficiaryFacet is\n    IIDABeneficiary,\n    IDABeneficiaryInternal,\n    AccessControlInternal,\n    ERC165BaseInternal\n{\n    using SuperTokenV1Library for ISETH;\n\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('IDABeneficiaryFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize beneficiary\n     */\n    function initializeIDABeneficiary(\n        ISETH _token,\n        Beneficiary[] memory _beneficiaries\n    ) external {\n        require(\n            _isInitialized() == false,\n            'IDABeneficiaryFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IBeneficiary).interfaceId, true);\n        _initializeIDABeneficiary(_token, _beneficiaries);\n    }\n\n    /**\n     * @notice Initialize beneficiary\n     */\n    function initializeIDABeneficiary(\n        address _owner,\n        ISETH _token,\n        Beneficiary[] memory _beneficiaries\n    ) external {\n        require(\n            _isInitialized() == false,\n            'IDABeneficiaryFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IBeneficiary).interfaceId, true);\n        _setSupportsInterface(type(IIDABeneficiary).interfaceId, true);\n        _grantRole(COMPONENT_ROLE, _owner);\n        _initializeIDABeneficiary(_token, _beneficiaries);\n    }\n\n    /**\n     * @notice Update beneficiaries\n     */\n    function updateBeneficiaryUnits(\n        Beneficiary[] memory _beneficiaries\n    ) external onlyRole(COMPONENT_ROLE) {\n        _updateBeneficiaryUnits(_beneficiaries);\n    }\n\n    /**\n     * @notice Distribute to beneficiaries\n     */\n    function distribute() external payable {\n        require(\n            msg.value > 0,\n            'IDABeneficiaryFacet: msg.value should be greater than 0'\n        );\n\n        _distribute(msg.value);\n    }\n}\n"
    },
    "contracts/beneficiary/IBeneficiary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IBeneficiary\n */\ninterface IBeneficiary {\n    /**\n     * @notice Distribute to beneficiaries\n     */\n    function distribute() external payable;\n}\n"
    },
    "contracts/beneficiary/IDABeneficiaryInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\nimport { SuperTokenV1Library } from '@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol';\nimport { IDABeneficiaryStorage } from './IDABeneficiaryStorage.sol';\nimport { IIDABeneficiaryInternal } from './IIDABeneficiaryInternal.sol';\n\n/**\n * @title IDABeneficiaryInternal\n */\nabstract contract IDABeneficiaryInternal is IIDABeneficiaryInternal {\n    using SuperTokenV1Library for ISETH;\n\n    /**\n     * @notice Initialize beneficiary\n     */\n    function _initializeIDABeneficiary(\n        ISETH _token,\n        Beneficiary[] memory _beneficiaries\n    ) internal {\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\n\n        l.isInitialized = true;\n\n        _setToken(_token);\n        _updateBeneficiaryUnits(_beneficiaries);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return IDABeneficiaryStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Set token\n     */\n    function _setToken(ISETH _token) internal {\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\n\n        l.token = _token;\n        l.token.createIndex(0);\n\n        emit TokenSet(address(_token));\n    }\n\n    /**\n     * @notice Update beneficiary units\n     */\n    function _updateBeneficiaryUnits(\n        Beneficiary[] memory _beneficiaries\n    ) internal {\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\n\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            l.token.updateSubscriptionUnits(\n                0,\n                _beneficiaries[i].subscriber,\n                _beneficiaries[i].units\n            );\n\n            emit BeneficiaryUnitsUpdated(\n                _beneficiaries[i].subscriber,\n                _beneficiaries[i].units\n            );\n        }\n    }\n\n    /**\n     * @notice Distribute to beneficiaries\n     */\n    function _distribute(uint256 value) internal {\n        IDABeneficiaryStorage.Layout storage l = IDABeneficiaryStorage.layout();\n\n        // Wrap ETH\n        l.token.upgradeByETH{ value: value }();\n\n        // Distribute to beneficiaries\n        l.token.distribute(0, value);\n\n        emit Distributed(value);\n    }\n}\n"
    },
    "contracts/beneficiary/IDABeneficiaryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ISETH } from '@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol';\n\n/**\n * @title IDABeneficiaryStorage\n */\nlibrary IDABeneficiaryStorage {\n    struct Layout {\n        bool isInitialized;\n        ISETH token;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.IDABeneficiaryStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/beneficiary/IIDABeneficiary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IBeneficiary } from './IBeneficiary.sol';\nimport { IIDABeneficiaryInternal } from './IIDABeneficiaryInternal.sol';\n\n/**\n * @title IIDABeneficiary\n */\ninterface IIDABeneficiary is IBeneficiary, IIDABeneficiaryInternal {\n    /**\n     * @notice Update beneficiary units\n     */\n    function updateBeneficiaryUnits(\n        Beneficiary[] memory _beneficiaries\n    ) external;\n}\n"
    },
    "contracts/beneficiary/IIDABeneficiaryInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IIDABeneficiaryInternal\n */\ninterface IIDABeneficiaryInternal {\n    struct Beneficiary {\n        address subscriber;\n        uint128 units;\n    }\n\n    event TokenSet(address indexed token);\n    event BeneficiaryUnitsUpdated(address indexed subscriber, uint128 units);\n    event Distributed(uint256 amount);\n}\n"
    },
    "contracts/license/facets/NativeStewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { IStewardLicense } from '../IStewardLicense.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\n\n/**\n * @title NativeStewardLicenseFacet\n * @dev ERC-1155 token license for Steward. Transfers are disabled during an auction\n */\ncontract NativeStewardLicenseFacet is\n    StewardLicenseInternal,\n    StewardLicenseBase\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeStewardLicense(\n        address _minter,\n        address _steward,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) external {\n        require(\n            _isInitialized() == false,\n            'StewardLicenseFacet: already initialized'\n        );\n\n        _initializeStewardLicense(_minter, _steward, name, symbol, baseURI);\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n}\n"
    },
    "contracts/license/facets/NativeStewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { NativeStewardLicenseFacet } from './NativeStewardLicenseFacet.sol';\nimport { IStewardLicense } from '../IStewardLicense.sol';\n\ncontract NativeStewardLicenseMock is NativeStewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n\n    function burn(uint256 tokenId) external {\n        _burn(tokenId);\n    }\n\n    function testTriggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        IStewardLicense(address(this)).triggerTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/license/facets/SolidStateERC1155Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SolidStateERC1155 } from '@solidstate/contracts/token/ERC1155/SolidStateERC1155.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\nimport { ERC1155MetadataStorage } from '@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol';\n\ncontract SolidStateERC1155Mock is SolidStateERC1155 {\n    constructor(string memory tokenURI) {\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n        _setSupportsInterface(type(IERC1155).interfaceId, true);\n\n        ERC1155MetadataStorage.layout().tokenURIs[0] = tokenURI;\n    }\n\n    function __mint(address account, uint256 id, uint256 amount) external {\n        _mint(account, id, amount, '');\n    }\n}\n"
    },
    "contracts/license/facets/SolidStateERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SolidStateERC721 } from '@solidstate/contracts/token/ERC721/SolidStateERC721.sol';\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\n\ncontract SolidStateERC721Mock is SolidStateERC721 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) {\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n        l.name = name;\n        l.symbol = symbol;\n        l.baseURI = baseURI;\n\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n        _setSupportsInterface(type(IERC721).interfaceId, true);\n    }\n\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC1155StewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\nimport { IERC1155Metadata } from '@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol';\nimport { DiamondBaseStorage } from '@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol';\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\nimport { IERC1155Receiver } from '@solidstate/contracts/interfaces/IERC1155Receiver.sol';\nimport { WrappedStewardLicenseInternal } from '../WrappedStewardLicenseInternal.sol';\n\n/**\n * @title WrappedERC1155StewardLicenseFacet\n * @dev ERC-721 token license for Steward that wraps existing ERC-1155. Transfers are disabled during an auction.\n */\ncontract WrappedERC1155StewardLicenseFacet is\n    StewardLicenseInternal,\n    WrappedStewardLicenseInternal,\n    StewardLicenseBase,\n    IERC1155Receiver\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeWrappedStewardLicense(\n        address tokenAddress,\n        uint256 tokenId,\n        address _minter,\n        address _steward,\n        string memory name,\n        string memory symbol,\n        string memory tokenURI\n    ) external {\n        require(\n            _isInitialized() == false,\n            'WrappedERC1155StewardLicenseFacet: already initialized'\n        );\n\n        _initializeWrappedLicense(tokenAddress, tokenId);\n        _initializeStewardLicense(_minter, _steward, name, symbol, tokenURI);\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            value == 1,\n            'WrappedERC1155StewardLicenseFacet: can only receive one token'\n        );\n\n        require(\n            _isInitialized() == true,\n            'WrappedERC1155StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            id == _wrappedTokenId(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            ids.length == 1 && values.length == 1 && values[0] == 1,\n            'WrappedERC1155StewardLicenseFacet: can only receive one token'\n        );\n\n        require(\n            _isInitialized() == true,\n            'WrappedERC1155StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            ids[0] == _wrappedTokenId(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC1155StewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedERC1155StewardLicenseFacet } from './WrappedERC1155StewardLicenseFacet.sol';\n\ncontract WrappedERC1155StewardLicenseMock is WrappedERC1155StewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC721StewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC721Base, ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/base/ERC721Base.sol';\nimport { ERC721Enumerable } from '@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol';\nimport { IERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol';\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { IERC721Receiver } from '@solidstate/contracts/interfaces/IERC721Receiver.sol';\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { DiamondBaseStorage } from '@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol';\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { WrappedStewardLicenseInternal } from '../WrappedStewardLicenseInternal.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\n\n/**\n * @title WrappedERC721StewardLicenseFacet\n * @dev ERC-721 token license for Steward that wraps existing ERC-721. Only a particular ERC721 transfer is accepted.\n */\ncontract WrappedERC721StewardLicenseFacet is\n    StewardLicenseInternal,\n    WrappedStewardLicenseInternal,\n    StewardLicenseBase,\n    IERC721Receiver\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeWrappedStewardLicense(\n        address tokenAddress,\n        uint256 tokenId,\n        address _minter,\n        address _steward,\n        string memory name,\n        string memory symbol,\n        string memory tokenURI\n    ) external {\n        require(\n            _isInitialized() == false,\n            'WrappedERC721StewardLicenseFacet: already initialized'\n        );\n\n        _initializeWrappedLicense(tokenAddress, tokenId);\n        _initializeStewardLicense(_minter, _steward, name, symbol, tokenURI);\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            _isInitialized() == true,\n            'WrappedERC721StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC721StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            tokenId == _wrappedTokenId(),\n            'WrappedERC721StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC721StewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedERC721StewardLicenseFacet } from './WrappedERC721StewardLicenseFacet.sol';\n\ncontract WrappedERC721StewardLicenseMock is WrappedERC721StewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n}\n"
    },
    "contracts/license/IStewardLicense.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol';\n\n/**\n * @title IStewardLicense\n */\ninterface IStewardLicense is IERC721, IERC721Metadata {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/license/StewardLicenseBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from './StewardLicenseInternal.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\n\n/**\n * @title StewardLicenseBase\n */\nabstract contract StewardLicenseBase is IERC721, StewardLicenseInternal {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        require(\n            msg.sender == address(this),\n            'NativeStewardLicense: Trigger transfer can only be called from another facet'\n        );\n\n        if (_exists(tokenId) == false) {\n            // Mint token\n            _mint(to, tokenId);\n        } else {\n            // Safe transfer is not needed. If receiver does not implement ERC721Receiver, next auction can still happen. This prevents a failed transfer from locking up license\n            _transfer(from, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n}\n"
    },
    "contracts/license/StewardLicenseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseStorage } from './StewardLicenseStorage.sol';\nimport { ERC721Base, ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/base/ERC721Base.sol';\nimport { ERC721Enumerable } from '@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol';\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IPeriodicAuctionReadable } from '../auction/IPeriodicAuctionReadable.sol';\n\n/**\n * @title StewardLicenseInternal\n */\nabstract contract StewardLicenseInternal is\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base\n{\n    /**\n     * @notice Initialize license\n     */\n    function _initializeStewardLicense(\n        address minter,\n        address _initialSteward,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) internal {\n        StewardLicenseStorage.Layout storage l = StewardLicenseStorage.layout();\n\n        l.isInitialized = true;\n        l.initialSteward = _initialSteward;\n        l.minter = minter;\n\n        // Initialize ERC721\n        ERC721MetadataStorage.Layout storage ls = ERC721MetadataStorage\n            .layout();\n        ls.name = name;\n        ls.symbol = symbol;\n        ls.baseURI = baseURI;\n\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n        _setSupportsInterface(type(IERC721).interfaceId, true);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return StewardLicenseStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function _minter() internal view returns (address) {\n        return StewardLicenseStorage.layout().minter;\n    }\n\n    /**\n     * @notice Disable transfers if during auction period\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        // Disable transfers if not mint\n        if (from != address(0x0)) {\n            bool isAuctionPeriod = IPeriodicAuctionReadable(address(this))\n                .isAuctionPeriod(tokenId);\n            require(\n                isAuctionPeriod == false,\n                'StewardLicenseFacet: Cannot transfer during auction period'\n            );\n        }\n\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/license/StewardLicenseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title StewardLicenseStorage\n */\nlibrary StewardLicenseStorage {\n    struct Layout {\n        bool isInitialized;\n        address initialSteward;\n        address minter;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.StewardLicenseStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/license/WrappedStewardLicenseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedStewardLicenseStorage } from './WrappedStewardLicenseStorage.sol';\n\n/**\n * @title WrappedStewardLicenseInternal\n */\nabstract contract WrappedStewardLicenseInternal {\n    /**\n     * @notice Initialize license\n     */\n    function _initializeWrappedLicense(\n        address wrappedTokenAddress,\n        uint256 wrappedTokenId\n    ) internal {\n        WrappedStewardLicenseStorage.Layout\n            storage l = WrappedStewardLicenseStorage.layout();\n\n        l.wrappedTokenAddress = wrappedTokenAddress;\n        l.wrappedTokenId = wrappedTokenId;\n    }\n\n    /**\n     * @notice Get wrapped token address\n     */\n    function _wrappedTokenAddress() internal view returns (address) {\n        return WrappedStewardLicenseStorage.layout().wrappedTokenAddress;\n    }\n\n    /**\n     * @notice Get wrapped token ID\n     */\n    function _wrappedTokenId() internal view returns (uint256) {\n        return WrappedStewardLicenseStorage.layout().wrappedTokenId;\n    }\n}\n"
    },
    "contracts/license/WrappedStewardLicenseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title WrappedStewardLicenseStorage\n */\nlibrary WrappedStewardLicenseStorage {\n    struct Layout {\n        address wrappedTokenAddress;\n        uint256 wrappedTokenId;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.WrappedStewardLicenseStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/pco/facets/PeriodicPCOParamsFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IPeriodicPCOParamsReadable } from '../IPeriodicPCOParamsReadable.sol';\nimport { IPeriodicPCOParamsWritable } from '../IPeriodicPCOParamsWritable.sol';\nimport { PeriodicPCOParamsInternal } from '../PeriodicPCOParamsInternal.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\n\n/**\n * @title PeriodicPCOParamsFacet\n * @dev Params store for periodic PCO\n */\ncontract PeriodicPCOParamsFacet is\n    AccessControlInternal,\n    IPeriodicPCOParamsReadable,\n    IPeriodicPCOParamsWritable,\n    PeriodicPCOParamsInternal,\n    ERC165BaseInternal\n{\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('PeriodicPCOParamsFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize params\n     */\n    function initializePCOParams(\n        uint256 _licensePeriod,\n        uint256 _feeNumerator,\n        uint256 _feeDenominator\n    ) external {\n        require(\n            _isInitialized() == false,\n            'PeriodicPCOParamsFacet: already initialized'\n        );\n\n        _setSupportsInterface(\n            type(IPeriodicPCOParamsReadable).interfaceId,\n            true\n        );\n        _initializeParams(_licensePeriod, _feeNumerator, _feeDenominator);\n    }\n\n    /**\n     * @notice Initialize params with owner\n     */\n    function initializePCOParams(\n        address _owner,\n        uint256 _licensePeriod,\n        uint256 _feeNumerator,\n        uint256 _feeDenominator\n    ) external {\n        require(\n            _isInitialized() == false,\n            'PeriodicPCOParamsFacet: already initialized'\n        );\n\n        _setSupportsInterface(\n            type(IPeriodicPCOParamsReadable).interfaceId,\n            true\n        );\n        _setSupportsInterface(\n            type(IPeriodicPCOParamsWritable).interfaceId,\n            true\n        );\n        _grantRole(COMPONENT_ROLE, _owner);\n        _initializeParams(_licensePeriod, _feeNumerator, _feeDenominator);\n    }\n\n    /**\n     * @notice Set PCO parameters\n     */\n    function setPCOParameters(\n        uint256 _licensePeriod,\n        uint256 _feeNumerator,\n        uint256 _feeDenominator\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setPCOParameters(_licensePeriod, _feeNumerator, _feeDenominator);\n    }\n\n    /**\n     * @notice Get license period\n     */\n    function licensePeriod() external view returns (uint256) {\n        return _licensePeriod();\n    }\n\n    /**\n     * @notice Set license period\n     */\n    function setLicensePeriod(\n        uint256 _licensePeriod\n    ) external onlyRole(COMPONENT_ROLE) {\n        return _setLicensePeriod(_licensePeriod);\n    }\n\n    /**\n     * @notice Get fee numerator\n     */\n    function feeNumerator() external view returns (uint256) {\n        return _feeNumerator();\n    }\n\n    /**\n     * @notice Set fee numerator\n     */\n    function setFeeNumerator(\n        uint256 _feeNumerator\n    ) external onlyRole(COMPONENT_ROLE) {\n        return _setFeeNumerator(_feeNumerator);\n    }\n\n    /**\n     * @notice Get fee denominator\n     */\n    function feeDenominator() external view returns (uint256) {\n        return _feeDenominator();\n    }\n\n    /**\n     * @notice Set fee denominator\n     */\n    function setFeeDenominator(\n        uint256 _feeDenominator\n    ) external onlyRole(COMPONENT_ROLE) {\n        return _setFeeDenominator(_feeDenominator);\n    }\n}\n"
    },
    "contracts/pco/IPeriodicPCOParamsInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicPCOParamsInternal\n */\ninterface IPeriodicPCOParamsInternal {\n    event LicensePeriodSet(uint256 licensePeriod);\n    event FeeNumeratorSet(uint256 feeNumerator);\n    event FeeDenominatorSet(uint256 feeDenominator);\n}\n"
    },
    "contracts/pco/IPeriodicPCOParamsReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicPCOParamsReadable\n */\ninterface IPeriodicPCOParamsReadable {\n    /**\n     * @notice Get license period\n     */\n    function licensePeriod() external view returns (uint256);\n\n    /**\n     * @notice Get fee numerator\n     */\n    function feeNumerator() external view returns (uint256);\n\n    /**\n     * @notice Get fee denominator\n     */\n    function feeDenominator() external view returns (uint256);\n}\n"
    },
    "contracts/pco/IPeriodicPCOParamsWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicPCOParamsWritable\n */\ninterface IPeriodicPCOParamsWritable {\n    /**\n     * @notice Set license period\n     */\n    function setLicensePeriod(uint256 _licensePeriod) external;\n\n    /**\n     * @notice Set fee numerator\n     */\n    function setFeeNumerator(uint256 _feeNumerator) external;\n\n    /**\n     * @notice Set fee denominator\n     */\n    function setFeeDenominator(uint256 _feeDenominator) external;\n}\n"
    },
    "contracts/pco/PeriodicPCOParamsInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { PeriodicPCOParamsStorage } from './PeriodicPCOParamsStorage.sol';\nimport { IPeriodicPCOParamsInternal } from './IPeriodicPCOParamsInternal.sol';\n\n/**\n * @title PeriodicPCOParamsInternal\n */\nabstract contract PeriodicPCOParamsInternal is IPeriodicPCOParamsInternal {\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeParams(\n        uint256 licensePeriod,\n        uint256 feeNumerator,\n        uint256 feeDenominator\n    ) internal {\n        PeriodicPCOParamsStorage.Layout storage l = PeriodicPCOParamsStorage\n            .layout();\n\n        l.isInitialized = true;\n\n        _setLicensePeriod(licensePeriod);\n        _setFeeNumerator(feeNumerator);\n        _setFeeDenominator(feeDenominator);\n    }\n\n    /**\n     * @notice Set PCO parameters\n     */\n    function _setPCOParameters(\n        uint256 licensePeriod,\n        uint256 feeNumerator,\n        uint256 feeDenominator\n    ) internal {\n        _setLicensePeriod(licensePeriod);\n        _setFeeNumerator(feeNumerator);\n        _setFeeDenominator(feeDenominator);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return PeriodicPCOParamsStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get license period\n     */\n    function _licensePeriod() internal view returns (uint256) {\n        return PeriodicPCOParamsStorage.layout().licensePeriod;\n    }\n\n    /**\n     * @notice Set license period\n     */\n    function _setLicensePeriod(uint256 licensePeriod) internal {\n        PeriodicPCOParamsStorage.Layout storage l = PeriodicPCOParamsStorage\n            .layout();\n\n        l.licensePeriod = licensePeriod;\n\n        emit LicensePeriodSet(licensePeriod);\n    }\n\n    /**\n     * @notice Get fee numerator\n     */\n    function _feeNumerator() internal view returns (uint256) {\n        return PeriodicPCOParamsStorage.layout().feeNumerator;\n    }\n\n    /**\n     * @notice Set fee numerator\n     */\n    function _setFeeNumerator(uint256 feeNumerator) internal {\n        PeriodicPCOParamsStorage.Layout storage l = PeriodicPCOParamsStorage\n            .layout();\n\n        l.feeNumerator = feeNumerator;\n\n        emit FeeNumeratorSet(feeNumerator);\n    }\n\n    /**\n     * @notice Get fee denominator\n     */\n    function _feeDenominator() internal view returns (uint256) {\n        return PeriodicPCOParamsStorage.layout().feeDenominator;\n    }\n\n    /**\n     * @notice Set fee denominator\n     */\n    function _setFeeDenominator(uint256 feeDenominator) internal {\n        PeriodicPCOParamsStorage.Layout storage l = PeriodicPCOParamsStorage\n            .layout();\n        l.feeDenominator = feeDenominator;\n\n        emit FeeDenominatorSet(feeDenominator);\n    }\n}\n"
    },
    "contracts/pco/PeriodicPCOParamsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title PeriodicPCOParamsStorage\n */\nlibrary PeriodicPCOParamsStorage {\n    struct Layout {\n        bool isInitialized;\n        /// @dev Length of time in seconds for each period the license is valid for\n        uint256 licensePeriod;\n        /// @dev Fee numerator\n        uint256 feeNumerator;\n        /// @dev Fee denominator\n        uint256 feeDenominator;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.PeriodicPCOParamsStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/proxies/beacon/BeaconDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/******************************************************************************\\\n* EIP-2535 Diamonds implementation that uses an external IDiamondReadable to store facet addresses.\n* Can be used to store a single set of facet addresses for many diamonds\n/******************************************************************************/\n\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\nimport { Proxy } from '@solidstate/contracts/proxy/Proxy.sol';\nimport { BeaconDiamondStorage } from './BeaconDiamondStorage.sol';\nimport { BeaconDiamondInternal } from './BeaconDiamondInternal.sol';\n\ncontract BeaconDiamond is Proxy, BeaconDiamondInternal {\n    error BeaconDiamond__NoFacetForSignature();\n\n    constructor(IDiamondReadable _beacon) {\n        _setBeacon(_beacon);\n    }\n\n    function _getImplementation() internal view override returns (address) {\n        BeaconDiamondStorage.Layout storage l = BeaconDiamondStorage.layout();\n\n        address implementation = l.beacon.facetAddress(msg.sig);\n\n        if (implementation == address(0)) {\n            revert BeaconDiamond__NoFacetForSignature();\n        }\n\n        return implementation;\n    }\n}\n"
    },
    "contracts/proxies/beacon/BeaconDiamondInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\nimport { BeaconDiamondStorage } from './BeaconDiamondStorage.sol';\n\nabstract contract BeaconDiamondInternal {\n    function _setBeacon(IDiamondReadable beacon) internal {\n        BeaconDiamondStorage.Layout storage l = BeaconDiamondStorage.layout();\n        l.beacon = beacon;\n    }\n}\n"
    },
    "contracts/proxies/beacon/BeaconDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol';\n\nlibrary BeaconDiamondStorage {\n    struct Layout {\n        /// @notice Beacon that stores facet addresses\n        IDiamondReadable beacon;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.BeaconDiamond');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/proxies/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IDiamond {\n    struct FacetInit {\n        address target;\n        address initTarget;\n        bytes initData;\n        bytes4[] selectors;\n    }\n}\n"
    },
    "contracts/proxies/IDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IDiamond } from './IDiamond.sol';\n\ninterface IDiamondFactory is IDiamond {\n    event DiamondCreated(address indexed diamondAddress);\n\n    function createDiamond(\n        FacetInit[] memory facetInits\n    ) external returns (address);\n}\n"
    },
    "contracts/proxies/OwnableDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ISolidStateDiamond } from '@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC173 } from '@solidstate/contracts/interfaces/IERC173.sol';\nimport { ERC165Base, ERC165BaseStorage } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { DiamondBase } from '@solidstate/contracts/proxy/diamond/base/DiamondBase.sol';\nimport { DiamondReadable, IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol';\nimport { DiamondWritable, IDiamondWritable } from '@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol';\nimport { DiamondFallback, IDiamondFallback } from '@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol';\nimport { SafeOwnable } from '@solidstate/contracts/access/ownable/SafeOwnable.sol';\nimport { Ownable, OwnableInternal } from '@solidstate/contracts/access/ownable/Ownable.sol';\nimport { IDiamond } from './IDiamond.sol';\n\ncontract OwnableDiamond is\n    ISolidStateDiamond,\n    DiamondBase,\n    DiamondFallback,\n    DiamondReadable,\n    DiamondWritable,\n    SafeOwnable,\n    IDiamond,\n    ERC165Base\n{\n    constructor(address owner, FacetInit[] memory facetInits) {\n        bytes4[] memory selectors = new bytes4[](12);\n        uint256 selectorIndex;\n\n        // register DiamondFallback\n\n        selectors[selectorIndex++] = IDiamondFallback\n            .getFallbackAddress\n            .selector;\n        selectors[selectorIndex++] = IDiamondFallback\n            .setFallbackAddress\n            .selector;\n\n        _setSupportsInterface(type(IDiamondFallback).interfaceId, true);\n\n        // register DiamondWritable\n\n        selectors[selectorIndex++] = IDiamondWritable.diamondCut.selector;\n\n        _setSupportsInterface(type(IDiamondWritable).interfaceId, true);\n\n        // register DiamondReadable\n\n        selectors[selectorIndex++] = IDiamondReadable.facets.selector;\n        selectors[selectorIndex++] = IDiamondReadable\n            .facetFunctionSelectors\n            .selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\n\n        _setSupportsInterface(type(IDiamondReadable).interfaceId, true);\n\n        // register ERC165\n\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\n\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n\n        // register SafeOwnable\n\n        selectors[selectorIndex++] = Ownable.owner.selector;\n        selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\n        selectors[selectorIndex++] = Ownable.transferOwnership.selector;\n        selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\n\n        _setSupportsInterface(type(IERC173).interfaceId, true);\n\n        // diamond cut\n\n        FacetCut[] memory builtInFacetCuts = new FacetCut[](1);\n\n        builtInFacetCuts[0] = FacetCut({\n            target: address(this),\n            action: FacetCutAction.ADD,\n            selectors: selectors\n        });\n\n        _diamondCut(builtInFacetCuts, address(0), '');\n\n        for (uint256 facetIndex; facetIndex < facetInits.length; facetIndex++) {\n            FacetInit memory facetInit = facetInits[facetIndex];\n            FacetCut[] memory facetCuts = new FacetCut[](1);\n            facetCuts[0] = FacetCut({\n                target: facetInit.target,\n                action: FacetCutAction.ADD,\n                selectors: facetInit.selectors\n            });\n\n            _diamondCut(facetCuts, facetInit.initTarget, facetInit.initData);\n        }\n\n        // set owner\n        _setOwner(owner);\n    }\n\n    receive() external payable {}\n\n    function _transferOwnership(\n        address account\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\n        super._transferOwnership(account);\n    }\n\n    /**\n     * @inheritdoc DiamondFallback\n     */\n    function _getImplementation()\n        internal\n        view\n        override(DiamondBase, DiamondFallback)\n        returns (address implementation)\n    {\n        implementation = super._getImplementation();\n    }\n}\n"
    },
    "contracts/proxies/OwnableDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { ERC165Base, ERC165BaseStorage } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { DiamondBase } from '@solidstate/contracts/proxy/diamond/base/DiamondBase.sol';\nimport { DiamondReadable, IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol';\nimport { DiamondWritableInternal } from '@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol';\nimport { OwnableDiamond } from './OwnableDiamond.sol';\nimport { IDiamondFactory } from './IDiamondFactory.sol';\n\ncontract OwnableDiamondFactory is IDiamondFactory {\n    function createDiamond(\n        FacetInit[] memory facetInits\n    ) external returns (address) {\n        OwnableDiamond ownableDiamond = new OwnableDiamond(\n            msg.sender,\n            facetInits\n        );\n\n        emit DiamondCreated(address(ownableDiamond));\n\n        return address(ownableDiamond);\n    }\n}\n"
    },
    "contracts/proxies/SingleCutDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { ERC165Base, ERC165BaseStorage } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { DiamondBase } from '@solidstate/contracts/proxy/diamond/base/DiamondBase.sol';\nimport { DiamondReadable, IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol';\nimport { DiamondWritableInternal } from '@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol';\nimport { IDiamond } from './IDiamond.sol';\n\n/******************************************************************************\\\n* EIP-2535 Diamonds implementation that is a single cut with no diamondCut selector after deployment\n/******************************************************************************/\n\ncontract SingleCutDiamond is\n    DiamondBase,\n    DiamondReadable,\n    DiamondWritableInternal,\n    ERC165Base,\n    IDiamond\n{\n    constructor(FacetInit[] memory facetInits) {\n        bytes4[] memory selectors = new bytes4[](5);\n        uint256 selectorIndex;\n\n        // register DiamondReadable\n\n        selectors[selectorIndex++] = IDiamondReadable.facets.selector;\n        selectors[selectorIndex++] = IDiamondReadable\n            .facetFunctionSelectors\n            .selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\n\n        _setSupportsInterface(type(IDiamondReadable).interfaceId, true);\n\n        // register ERC165\n\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\n\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n\n        // diamond cut\n\n        FacetCut[] memory builtInFacetCuts = new FacetCut[](1);\n\n        builtInFacetCuts[0] = FacetCut({\n            target: address(this),\n            action: FacetCutAction.ADD,\n            selectors: selectors\n        });\n\n        _diamondCut(builtInFacetCuts, address(0), '');\n\n        for (uint256 facetIndex; facetIndex < facetInits.length; facetIndex++) {\n            FacetInit memory facetInit = facetInits[facetIndex];\n            FacetCut[] memory facetCuts = new FacetCut[](1);\n            facetCuts[0] = FacetCut({\n                target: facetInit.target,\n                action: FacetCutAction.ADD,\n                selectors: facetInit.selectors\n            });\n\n            _diamondCut(facetCuts, facetInit.initTarget, facetInit.initData);\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/proxies/SingleCutDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { ERC165Base, ERC165BaseStorage } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { DiamondBase } from '@solidstate/contracts/proxy/diamond/base/DiamondBase.sol';\nimport { DiamondReadable, IDiamondReadable } from '@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol';\nimport { DiamondWritableInternal } from '@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol';\nimport { SingleCutDiamond } from './SingleCutDiamond.sol';\nimport { IDiamondFactory } from './IDiamondFactory.sol';\n\ncontract SingleCutDiamondFactory is IDiamondFactory {\n    function createDiamond(\n        FacetInit[] memory facetInits\n    ) external returns (address) {\n        SingleCutDiamond singleCutDiamond = new SingleCutDiamond(facetInits);\n\n        emit DiamondCreated(address(singleCutDiamond));\n\n        return address(singleCutDiamond);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
