{
  "language": "Solidity",
  "sources": {
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Map implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableMap {\n    error EnumerableMap__IndexOutOfBounds();\n    error EnumerableMap__NonExistentKey();\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct AddressToAddressMap {\n        Map _inner;\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function at(\n        AddressToAddressMap storage map,\n        uint256 index\n    ) internal view returns (address, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n\n        return (\n            address(uint160(uint256(key))),\n            address(uint160(uint256(value)))\n        );\n    }\n\n    function at(\n        UintToAddressMap storage map,\n        uint256 index\n    ) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function contains(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function contains(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(\n        AddressToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function length(\n        UintToAddressMap storage map\n    ) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function get(\n        AddressToAddressMap storage map,\n        address key\n    ) internal view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\n                )\n            );\n    }\n\n    function get(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function set(\n        AddressToAddressMap storage map,\n        address key,\n        address value\n    ) internal returns (bool) {\n        return\n            _set(\n                map._inner,\n                bytes32(uint256(uint160(key))),\n                bytes32(uint256(uint160(value)))\n            );\n    }\n\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        AddressToAddressMap storage map,\n        address key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    function remove(\n        UintToAddressMap storage map,\n        uint256 key\n    ) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function toArray(\n        AddressToAddressMap storage map\n    )\n        internal\n        view\n        returns (address[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function toArray(\n        UintToAddressMap storage map\n    )\n        internal\n        view\n        returns (uint256[] memory keysOut, address[] memory valuesOut)\n    {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function keys(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._key))\n                );\n            }\n        }\n    }\n\n    function keys(\n        UintToAddressMap storage map\n    ) internal view returns (uint256[] memory keysOut) {\n        uint256 len = map._inner._entries.length;\n\n        keysOut = new uint256[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                keysOut[i] = uint256(map._inner._entries[i]._key);\n            }\n        }\n    }\n\n    function values(\n        AddressToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function values(\n        UintToAddressMap storage map\n    ) internal view returns (address[] memory valuesOut) {\n        uint256 len = map._inner._entries.length;\n\n        valuesOut = new address[](len);\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                valuesOut[i] = address(\n                    uint160(uint256(map._inner._entries[i]._value))\n                );\n            }\n        }\n    }\n\n    function _at(\n        Map storage map,\n        uint256 index\n    ) private view returns (bytes32, bytes32) {\n        if (index >= map._entries.length)\n            revert EnumerableMap__IndexOutOfBounds();\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _contains(\n        Map storage map,\n        bytes32 key\n    ) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) revert EnumerableMap__NonExistentKey();\n        unchecked {\n            return map._entries[keyIndex - 1]._value;\n        }\n    }\n\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) {\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            unchecked {\n                map._entries[keyIndex - 1]._value = value;\n            }\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) {\n            unchecked {\n                MapEntry storage last = map._entries[map._entries.length - 1];\n\n                // move last entry to now-vacant index\n                map._entries[keyIndex - 1] = last;\n                map._indexes[last._key] = keyIndex;\n            }\n\n            // clear last index\n            map._entries.pop();\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC1155Internal } from './IERC1155Internal.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\n\n/**\n * @title ERC1155 transfer receiver interface\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @notice validate receipt of ERC1155 transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param id token ID received\n     * @param value quantity of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @notice validate receipt of ERC1155 batch transfer\n     * @param operator executor of transfer\n     * @param from sender of tokens\n     * @param ids token IDs received\n     * @param values quantities of tokens received\n     * @param data data payload\n     * @return function's own selector if transfer is accepted\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from './IERC165.sol';\nimport { IERC721Internal } from './IERC721Internal.sol';\n\n/**\n * @title ERC721 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Internal, IERC165 {\n    /**\n     * @notice query the balance of given address\n     * @return balance quantity of tokens held\n     */\n    function balanceOf(address account) external view returns (uint256 balance);\n\n    /**\n     * @notice query the owner of given token\n     * @param tokenId token to query\n     * @return owner token owner\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId token id\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @notice grant approval to given account to spend token\n     * @param operator address to be approved\n     * @param tokenId token to approve\n     */\n    function approve(address operator, uint256 tokenId) external payable;\n\n    /**\n     * @notice get approval status for given token\n     * @param tokenId token to query\n     * @return operator address approved to spend token\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\n     * @param operator address to be approved\n     * @param status approval status\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return status whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC721 interface needed by internal functions\n */\ninterface IERC721Internal {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed operator,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view virtual returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(\n        bytes4 interfaceId,\n        bool status\n    ) internal virtual {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"
    },
    "@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721Base } from './IERC721Base.sol';\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\n\n/**\n * @title Base ERC721 implementation, excluding optional extensions\n * @dev inheritor must either implement ERC165 supportsInterface or inherit ERC165Base\n */\nabstract contract ERC721Base is IERC721Base, ERC721BaseInternal {\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) external view returns (address) {\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) external view returns (address) {\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool) {\n        return _isApprovedForAll(account, operator);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address operator, uint256 tokenId) external payable {\n        _approve(operator, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool status) external {\n        _setApprovalForAll(operator, status);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Receiver } from '../../../interfaces/IERC721Receiver.sol';\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\n\n/**\n * @title Base ERC721 internal functions\n */\nabstract contract ERC721BaseInternal is IERC721BaseInternal {\n    using AddressUtils for address;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        if (account == address(0)) revert ERC721Base__BalanceQueryZeroAddress();\n        return ERC721BaseStorage.layout().holderTokens[account].length();\n    }\n\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\n        if (owner == address(0)) revert ERC721Base__InvalidOwner();\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().tokenOwners.contains(tokenId);\n    }\n\n    function _getApproved(\n        uint256 tokenId\n    ) internal view virtual returns (address) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        return ERC721BaseStorage.layout().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(\n        address account,\n        address operator\n    ) internal view virtual returns (bool) {\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\n    }\n\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        if (!_exists(tokenId)) revert ERC721Base__NonExistentToken();\n\n        address owner = _ownerOf(tokenId);\n\n        return (spender == owner ||\n            _getApproved(tokenId) == spender ||\n            _isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        if (to == address(0)) revert ERC721Base__MintToZeroAddress();\n        if (_exists(tokenId)) revert ERC721Base__TokenAlreadyMinted();\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, '');\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[owner].remove(tokenId);\n        l.tokenOwners.remove(tokenId);\n\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        address owner = _ownerOf(tokenId);\n\n        if (owner != from) revert ERC721Base__NotTokenOwner();\n        if (to == address(0)) revert ERC721Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\n\n        l.holderTokens[from].remove(tokenId);\n        l.holderTokens[to].add(tokenId);\n        l.tokenOwners.set(tokenId, to);\n        l.tokenApprovals[tokenId] = address(0);\n\n        emit Approval(owner, address(0), tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data))\n            revert ERC721Base__ERC721ReceiverNotImplemented();\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        _safeTransferFrom(from, to, tokenId, '');\n    }\n\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\n        if (!_isApprovedOrOwner(msg.sender, tokenId))\n            revert ERC721Base__NotOwnerOrApproved();\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _approve(address operator, uint256 tokenId) internal virtual {\n        _handleApproveMessageValue(operator, tokenId, msg.value);\n\n        address owner = _ownerOf(tokenId);\n\n        if (operator == owner) revert ERC721Base__SelfApproval();\n        if (msg.sender != owner && !_isApprovedForAll(owner, msg.sender))\n            revert ERC721Base__NotOwnerOrApproved();\n\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\n        emit Approval(owner, operator, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address operator,\n        bool status\n    ) internal virtual {\n        if (operator == msg.sender) revert ERC721Base__SelfApproval();\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\n            operator\n        ] = status;\n        emit ApprovalForAll(msg.sender, operator, status);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual returns (bool) {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes memory returnData = to.functionCall(\n            abi.encodeWithSelector(\n                IERC721Receiver(to).onERC721Received.selector,\n                msg.sender,\n                from,\n                tokenId,\n                data\n            ),\n            'ERC721: transfer to non ERC721Receiver implementer'\n        );\n\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\n        return returnValue == type(IERC721Receiver).interfaceId;\n    }\n\n    /**\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\n     * @param operator beneficiary of approval\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleApproveMessageValue(\n        address operator,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     * @param value message value\n     */\n    function _handleTransferMessageValue(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    ) internal virtual {}\n\n    /**\n     * @notice ERC721 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of token\n     * @param to receiver of token\n     * @param tokenId id of transferred token\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC721BaseStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Base');\n\n    struct Layout {\n        EnumerableMap.UintToAddressMap tokenOwners;\n        mapping(address => EnumerableSet.UintSet) holderTokens;\n        mapping(uint256 => address) tokenApprovals;\n        mapping(address => mapping(address => bool)) operatorApprovals;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721 } from '../../../interfaces/IERC721.sol';\nimport { IERC721BaseInternal } from './IERC721BaseInternal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721Base is IERC721BaseInternal, IERC721 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC721/base/IERC721BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721Internal } from '../../../interfaces/IERC721Internal.sol';\n\n/**\n * @title ERC721 base interface\n */\ninterface IERC721BaseInternal is IERC721Internal {\n    error ERC721Base__NotOwnerOrApproved();\n    error ERC721Base__SelfApproval();\n    error ERC721Base__BalanceQueryZeroAddress();\n    error ERC721Base__ERC721ReceiverNotImplemented();\n    error ERC721Base__InvalidOwner();\n    error ERC721Base__MintToZeroAddress();\n    error ERC721Base__NonExistentToken();\n    error ERC721Base__NotTokenOwner();\n    error ERC721Base__TokenAlreadyMinted();\n    error ERC721Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\n\nabstract contract ERC721Enumerable is\n    IERC721Enumerable,\n    ERC721EnumerableInternal\n{\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) public view returns (uint256) {\n        return _tokenOfOwnerByIndex(owner, index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        return _tokenByIndex(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableMap } from '../../../data/EnumerableMap.sol';\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\n\nabstract contract ERC721EnumerableInternal {\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * @notice TODO\n     */\n    function _totalSupply() internal view returns (uint256) {\n        return ERC721BaseStorage.layout().tokenOwners.length();\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) internal view returns (uint256) {\n        return ERC721BaseStorage.layout().holderTokens[owner].at(index);\n    }\n\n    /**\n     * @notice TODO\n     */\n    function _tokenByIndex(\n        uint256 index\n    ) internal view returns (uint256 tokenId) {\n        (tokenId, ) = ERC721BaseStorage.layout().tokenOwners.at(index);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC721Enumerable {\n    /**\n     * @notice get total token supply\n     * @return total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice get token of given owner at given internal storage index\n     * @param owner token holder to query\n     * @param index position in owner's token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenOfOwnerByIndex(\n        address owner,\n        uint256 index\n    ) external view returns (uint256 tokenId);\n\n    /**\n     * @notice get token at given internal storage index\n     * @param index position in global token list to query\n     * @return tokenId id of retrieved token\n     */\n    function tokenByIndex(\n        uint256 index\n    ) external view returns (uint256 tokenId);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\nimport { IERC721Metadata } from './IERC721Metadata.sol';\n\n/**\n * @title ERC721 metadata extensions\n */\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function name() external view virtual returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function symbol() external view virtual returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @notice inheritdoc IERC721Metadata\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) external view virtual returns (string memory) {\n        return _tokenURI(tokenId);\n    }\n\n    /**\n     * @inheritdoc ERC721MetadataInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from '../../../utils/UintUtils.sol';\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\n\n/**\n * @title ERC721Metadata internal functions\n */\nabstract contract ERC721MetadataInternal is\n    IERC721MetadataInternal,\n    ERC721BaseInternal\n{\n    using UintUtils for uint256;\n\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC721MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view virtual returns (string memory) {\n        if (!_exists(tokenId)) revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\n\n        string memory tokenIdURI = l.tokenURIs[tokenId];\n        string memory baseURI = l.baseURI;\n\n        if (bytes(baseURI).length == 0) {\n            return tokenIdURI;\n        } else if (bytes(tokenIdURI).length > 0) {\n            return string(abi.encodePacked(baseURI, tokenIdURI));\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice ERC721 hook: clear per-token URI data on burn\n     * @inheritdoc ERC721BaseInternal\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (to == address(0)) {\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC721MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\n\n    struct Layout {\n        string name;\n        string symbol;\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721MetadataInternal } from './IERC721MetadataInternal.sol';\n\n/**\n * @title ERC721Metadata interface\n */\ninterface IERC721Metadata is IERC721MetadataInternal {\n    /**\n     * @notice get token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC721/metadata/IERC721MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC721BaseInternal } from '../base/IERC721BaseInternal.sol';\n\n/**\n * @title ERC721Metadata internal interface\n */\ninterface IERC721MetadataInternal is IERC721BaseInternal {\n    error ERC721Metadata__NonExistentToken();\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/allowlist/IAllowlistReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IAllowlistReadable\n */\ninterface IAllowlistReadable {\n    /**\n     * @notice Check if address is allowed\n     */\n    function isAllowed(address _address) external view returns (bool);\n}\n"
    },
    "contracts/auction/EnglishPeriodicAuctionInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().highestBids[tokenId][round];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().bids[tokenId][round][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function _currentAuctionRound(\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().currentAuctionRound[tokenId];\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function _lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (uint256) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n        uint256 lockedCollateral = 0;\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n            lockedCollateral += bid.collateralAmount;\n        }\n\n        return lockedCollateral;\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function _availableCollateral(\n        address bidder\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().availableCollateral[bidder];\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        Bid storage bid = l.bids[tokenId][currentAuctionRound][bidder];\n\n        // Check if higher than starting bid\n        require(\n            bidAmount >= l.startingBid,\n            'EnglishPeriodicAuction: Bid amount must be greater than or equal to starting bid'\n        );\n\n        // Check if highest bid\n        if (l.highestBids[tokenId][currentAuctionRound].bidAmount > 0) {\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId][currentAuctionRound].bidAmount +\n                        l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId][currentAuctionRound] = bid;\n\n        emit BidPlaced(tokenId, currentAuctionRound, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        // slither-disable-start timestamp\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n        // slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Cancel bid for current round if not highest bidder\n     */\n    function _cancelBid(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][round][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No bid to cancel'\n        );\n\n        // Make collateral available to withdraw\n        l.availableCollateral[bidder] += bid.collateralAmount;\n\n        // Reset collateral and bid\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n    }\n\n    /**\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n\n            if (bid.collateralAmount > 0) {\n                // Make collateral available to withdraw\n                l.availableCollateral[bidder] += bid.collateralAmount;\n\n                // Reset collateral and bid\n                bid.collateralAmount = 0;\n                bid.bidAmount = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function _withdrawCollateral(address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 collateralAmount = l.availableCollateral[bidder];\n\n        require(\n            collateralAmount > 0,\n            'EnglishPeriodicAuction: No collateral to withdraw'\n        );\n\n        // Make collateral unavailable to withdraw\n        l.availableCollateral[bidder] = 0;\n\n        // Transfer collateral back to bidder\n        //slither-disable-next-line low-level-calls\n        (bool success, ) = bidder.call{ value: collateralAmount }('');\n        require(\n            success,\n            'EnglishPeriodicAuction: Failed to withdraw collateral'\n        );\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function _closeAuction(uint256 tokenId) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        address oldBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            oldBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            oldBidder = l.initialBidder;\n        }\n\n        // Set lastPeriodEndTime to the end of the current auction period\n        uint256 licensePeriod = IPeriodicPCOParamsReadable(address(this))\n            .licensePeriod();\n\n        l.lastPeriodEndTime[tokenId] = block.timestamp;\n        l.currentLicensePeriod[tokenId] = licensePeriod;\n\n        if (l.highestBids[tokenId][currentAuctionRound].bidder == address(0)) {\n            // No bids were placed, transfer to repossessor\n            Bid storage repossessorBid = l.bids[tokenId][currentAuctionRound][\n                l.repossessor\n            ];\n            repossessorBid.bidAmount = 0;\n            repossessorBid.feeAmount = 0;\n            repossessorBid.collateralAmount = 0;\n            repossessorBid.bidder = l.repossessor;\n\n            l.highestBids[tokenId][currentAuctionRound] = repossessorBid;\n        } else if (\n            l.highestBids[tokenId][currentAuctionRound].bidder != oldBidder\n        ) {\n            // Transfer bid to previous bidder's collateral\n            l.availableCollateral[oldBidder] += l\n            .highestBids[tokenId][currentAuctionRound].bidAmount;\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][\n                l.highestBids[tokenId][currentAuctionRound].bidder\n            ].collateralAmount = 0;\n        } else {\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][oldBidder].collateralAmount = 0;\n        }\n\n        emit AuctionClosed(\n            tokenId,\n            currentAuctionRound,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidAmount\n        );\n\n        // Reset auction\n        l.currentAuctionLength[tokenId] = 0;\n        l.currentAuctionRound[tokenId] = l.currentAuctionRound[tokenId] + 1;\n\n        // Transfer to highest bidder\n        IStewardLicense(address(this)).triggerTransfer(\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            tokenId\n        );\n\n        // Distribute fee to beneficiary\n        if (l.highestBids[tokenId][currentAuctionRound].feeAmount > 0) {\n            IBeneficiary(address(this)).distribute{\n                value: l.highestBids[tokenId][currentAuctionRound].feeAmount\n            }();\n        }\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function _auctionStartTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionStartTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        if (l.tokenInitialPeriodStartTime[tokenId] > 0) {\n            initialPeriodStartTime = l.tokenInitialPeriodStartTime[tokenId];\n            initialPeriodStartTimeOffset = 0;\n        } else {\n            initialPeriodStartTime = l.initialPeriodStartTime;\n            initialPeriodStartTimeOffset = l.initialPeriodStartTimeOffset;\n        }\n\n        if (l.lastPeriodEndTime[tokenId] > initialPeriodStartTime) {\n            // Auction starts after licensePeriod has elapsed\n            auctionStartTime =\n                l.lastPeriodEndTime[tokenId] +\n                l.currentLicensePeriod[tokenId];\n        } else {\n            // Auction starts at initial time\n            auctionStartTime =\n                initialPeriodStartTime +\n                (tokenId * initialPeriodStartTimeOffset);\n        }\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function _auctionEndTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionEndTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 auctionLengthSeconds;\n        if (l.currentAuctionLength[tokenId] == 0) {\n            auctionLengthSeconds = _auctionLengthSeconds();\n        } else {\n            auctionLengthSeconds = l.currentAuctionLength[tokenId];\n        }\n\n        auctionEndTime = _auctionStartTime(tokenId) + auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function _calculateFeeFromBid(\n        uint256 bidAmount\n    ) internal view returns (uint256) {\n        uint256 feeNumerator = IPeriodicPCOParamsReadable(address(this))\n            .feeNumerator();\n        uint256 feeDenominator = IPeriodicPCOParamsReadable(address(this))\n            .feeDenominator();\n\n        return (bidAmount * feeNumerator) / feeDenominator;\n    }\n\n    /**\n     * @notice Check that fee is within rounding error of bid amount\n     */\n    function _checkBidAmount(\n        uint256 bidAmount,\n        uint256 feeAmount\n    ) internal view returns (bool) {\n        uint256 calculatedFeeAmount = _calculateFeeFromBid(bidAmount);\n\n        return calculatedFeeAmount == feeAmount;\n    }\n}\n"
    },
    "contracts/auction/EnglishPeriodicAuctionStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\nlibrary EnglishPeriodicAuctionStorage {\n    struct Layout {\n        bool isInitialized;\n        // Same for all tokens\n        address initialBidder;\n        uint256 startingBid;\n        address repossessor;\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        uint256 auctionLengthSeconds;\n        uint256 minBidIncrement;\n        uint256 bidExtensionWindowLengthSeconds;\n        uint256 bidExtensionSeconds;\n        // Per token config\n        mapping(uint256 => uint256) tokenInitialPeriodStartTime;\n        mapping(uint256 => uint256) lastPeriodEndTime;\n        mapping(uint256 => uint256) currentLicensePeriod;\n        mapping(uint256 => uint256) currentAuctionRound;\n        mapping(uint256 => uint256) currentAuctionLength;\n        mapping(uint256 => mapping(uint256 => mapping(address => IEnglishPeriodicAuctionInternal.Bid))) bids;\n        mapping(uint256 => mapping(uint256 => IEnglishPeriodicAuctionInternal.Bid)) highestBids;\n        mapping(address => uint256) availableCollateral;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.EnglishPeriodicAuctionStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        //slither-disable-next-line assembly\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/auction/facets/EnglishPeriodicAuctionFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionInternal } from '../EnglishPeriodicAuctionInternal.sol';\nimport { IPeriodicAuctionReadable } from '../IPeriodicAuctionReadable.sol';\nimport { IPeriodicAuctionWritable } from '../IPeriodicAuctionWritable.sol';\nimport { IAllowlistReadable } from '../../allowlist/IAllowlistReadable.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionFacet\n */\ncontract EnglishPeriodicAuctionFacet is\n    IPeriodicAuctionReadable,\n    IPeriodicAuctionWritable,\n    EnglishPeriodicAuctionInternal,\n    AccessControlInternal,\n    ERC165BaseInternal\n{\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('EnglishPeriodicAuctionFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize auction parameters\n     */\n    function initializeAuction(\n        address repossessor_,\n        address initialBidder_,\n        uint256 initialPeriodStartTime_,\n        uint256 initialPeriodStartTimeOffset_,\n        uint256 startingBid_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_\n    ) external {\n        require(\n            !_isInitialized(),\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _initializeAuction(\n            repossessor_,\n            initialBidder_,\n            initialPeriodStartTime_,\n            initialPeriodStartTimeOffset_,\n            startingBid_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_\n        );\n    }\n\n    /**\n     * @notice Initialize auction parameters with owner\n     */\n    function initializeAuction(\n        address owner_,\n        address repossessor_,\n        address initialBidder_,\n        uint256 initialPeriodStartTime_,\n        uint256 initialPeriodStartTimeOffset_,\n        uint256 startingBid_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_\n    ) external {\n        require(\n            !_isInitialized(),\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _setSupportsInterface(type(IPeriodicAuctionWritable).interfaceId, true);\n        _grantRole(COMPONENT_ROLE, owner_);\n        _initializeAuction(\n            repossessor_,\n            initialBidder_,\n            initialPeriodStartTime_,\n            initialPeriodStartTimeOffset_,\n            startingBid_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_\n        );\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function setAuctionParameters(\n        address repossessor_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_,\n        uint256 startingBid_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionParameters(\n            repossessor_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_,\n            startingBid_\n        );\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function startingBid() external view returns (uint256) {\n        return _startingBid();\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function isAuctionPeriod(uint256 tokenId) external view returns (bool) {\n        return _isAuctionPeriod(tokenId);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function initialPeriodStartTime() external view returns (uint256) {\n        return _initialPeriodStartTime();\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function initialBidder() external view returns (address) {\n        return _initialBidder();\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function isReadyForTransfer(uint256 tokenId) external view returns (bool) {\n        return _isReadyForTransfer(tokenId);\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function placeBid(uint256 tokenId, uint256 bidAmount) external payable {\n        require(\n            _isAuctionPeriod(tokenId),\n            'EnglishPeriodicAuction: can only place bid in auction period'\n        );\n        require(\n            !_isReadyForTransfer(tokenId),\n            'EnglishPeriodicAuction: auction is over and awaiting transfer'\n        );\n        require(\n            IAllowlistReadable(address(this)).isAllowed(msg.sender),\n            'EnglishPeriodicAuction: sender is not allowed to place bid'\n        );\n\n        _placeBid(tokenId, msg.sender, bidAmount, msg.value);\n    }\n\n    /**\n     * @notice Cancel bid for current round\n     */\n    function cancelBid(uint256 tokenId, uint256 round) external {\n        _cancelBid(tokenId, round, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function withdrawCollateral() external {\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Cancel all bids and withdraw collateral\n     */\n    function cancelAllBidsAndWithdrawCollateral(uint256 tokenId) external {\n        _cancelAllBids(tokenId, msg.sender);\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Cancel bid for current round and withdraw collateral\n     */\n    function cancelBidAndWithdrawCollateral(\n        uint256 tokenId,\n        uint256 round\n    ) external {\n        _cancelBid(tokenId, round, msg.sender);\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) external view returns (uint256) {\n        return _lockedCollateral(tokenId, bidder);\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function availableCollateral(\n        address bidder\n    ) external view returns (uint256) {\n        return _availableCollateral(bidder);\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function closeAuction(uint256 tokenId) external {\n        require(\n            _isReadyForTransfer(tokenId),\n            'EnglishPeriodicAuction: auction is not over'\n        );\n\n        _closeAuction(tokenId);\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function calculateFeeFromBid(\n        uint256 bidAmount\n    ) external view returns (uint256) {\n        return _calculateFeeFromBid(bidAmount);\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function auctionStartTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function auctionEndTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function repossessor() external view returns (address) {\n        return _repossessor();\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function setStartingBid(\n        uint256 startingBid_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setStartingBid(startingBid_);\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function setRepossessor(\n        address repossessor_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setRepossessor(repossessor_);\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function auctionLengthSeconds() external view returns (uint256) {\n        return _auctionLengthSeconds();\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function setAuctionLengthSeconds(\n        uint256 auctionLengthSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionLengthSeconds(auctionLengthSeconds_);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function minBidIncrement() external view returns (uint256) {\n        return _minBidIncrement();\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function setMinBidIncrement(\n        uint256 minBidIncrement_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setMinBidIncrement(minBidIncrement_);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function bidExtensionWindowLengthSeconds() external view returns (uint256) {\n        return _bidExtensionWindowLengthSeconds();\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds_);\n    }\n\n    /**\n     *  @notice Get bid extension seconds\n     */\n    function bidExtensionSeconds() external view returns (uint256) {\n        return _bidExtensionSeconds();\n    }\n\n    /**\n     *  @notice Set bid extension seconds\n     */\n    function setBidExtensionSeconds(\n        uint256 bidExtensionSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionSeconds(bidExtensionSeconds_);\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function highestBid(uint256 tokenId) external view returns (Bid memory) {\n        return _highestBid(tokenId, _currentAuctionRound(tokenId));\n    }\n\n    /**\n     * @notice Get highest outstanding bid for a particular round\n     */\n    function highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) external view returns (Bid memory) {\n        return _highestBid(tokenId, round);\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function bidOf(\n        uint256 tokenId,\n        address bidder\n    ) external view returns (Bid memory) {\n        return _bidOf(tokenId, _currentAuctionRound(tokenId), bidder);\n    }\n\n    /**\n     * @notice Get bid for address for particular round\n     */\n    function bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) external view returns (Bid memory) {\n        return _bidOf(tokenId, round, bidder);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function currentAuctionRound(\n        uint256 tokenId\n    ) external view returns (uint256) {\n        return _currentAuctionRound(tokenId);\n    }\n}\n"
    },
    "contracts/auction/IEnglishPeriodicAuctionInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IEnglishPeriodicAuctionInternal\n */\ninterface IEnglishPeriodicAuctionInternal {\n    struct Bid {\n        address bidder;\n        uint256 bidAmount;\n        uint256 feeAmount;\n        uint256 collateralAmount;\n    }\n\n    event InitialPeriodStartTimeSet(uint256 initialPeriodStartTime);\n    event RepossessorSet(address repossessor);\n    event AuctionLengthSet(uint256 auctionLengthSeconds);\n    event MinBidIncrementSet(uint256 minBidIncrement);\n    event BidExtensionWindowLengthSet(uint256 bidExtensionWindowLengthSeconds);\n    event BidExtensionSet(uint256 bidExtensionSeconds);\n    event StartingBidSet(uint256 startingBid);\n\n    event BidPlaced(\n        uint256 indexed tokenId,\n        uint256 indexed round,\n        address indexed bidder,\n        uint256 bidAmount\n    );\n    event AuctionClosed(\n        uint256 indexed tokenId,\n        uint256 indexed round,\n        address indexed winningBidder,\n        address previousOwner,\n        uint256 bidAmount\n    );\n}\n"
    },
    "contracts/auction/IPeriodicAuctionReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicAuctionReadable\n */\ninterface IPeriodicAuctionReadable {\n    /**\n     * @notice Get is auction period\n     */\n    function isAuctionPeriod(uint256 tokenId) external view returns (bool);\n\n    /**\n     * @notice Get initial period start time\n     */\n    function initialPeriodStartTime() external view returns (uint256);\n\n    /**\n     * @notice Get initial bidder\n     */\n    function initialBidder() external view returns (address);\n}\n"
    },
    "contracts/auction/IPeriodicAuctionWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicAuctionWritable\n */\ninterface IPeriodicAuctionWritable {\n    /**\n     * @notice Set repossessor\n     */\n    function setRepossessor(address _repossessor) external;\n\n    /**\n     * @notice Set auction length\n     */\n    function setAuctionLengthSeconds(uint256 _auctionLengthSeconds) external;\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function setMinBidIncrement(uint256 _minBidIncrement) external;\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function setBidExtensionWindowLengthSeconds(\n        uint256 _bidExtensionWindowLengthSeconds\n    ) external;\n\n    /**\n     *  @notice Set bid extension seconds\n     */\n    function setBidExtensionSeconds(uint256 _bidExtensionSeconds) external;\n}\n"
    },
    "contracts/auction/mocks/MockBidder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionFacet } from '../facets/EnglishPeriodicAuctionFacet.sol';\n\ncontract MockBidder {\n    EnglishPeriodicAuctionFacet public auction;\n\n    constructor(EnglishPeriodicAuctionFacet _auction) {\n        auction = _auction;\n    }\n\n    // Cancel bid\n    function withdrawCollateral() external {\n        auction.withdrawCollateral();\n    }\n\n    // Fail on receive\n    receive() external payable {\n        revert('MockBidder: receive not allowed');\n    }\n}\n"
    },
    "contracts/beneficiary/IBeneficiary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IBeneficiary\n */\ninterface IBeneficiary {\n    /**\n     * @notice Distribute to beneficiaries\n     */\n    function distribute() external payable;\n}\n"
    },
    "contracts/license/facets/NativeStewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { IStewardLicense } from '../IStewardLicense.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\n\n/**\n * @title NativeStewardLicenseFacet\n * @dev ERC-1155 token license for Steward. Transfers are disabled during an auction\n */\ncontract NativeStewardLicenseFacet is\n    StewardLicenseInternal,\n    StewardLicenseBase\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeStewardLicense(\n        address minter_,\n        address addToCollectionMinter_,\n        address steward_,\n        uint256 maxTokenCount_,\n        bool shouldMint,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) external {\n        require(!_isInitialized(), 'StewardLicenseFacet: already initialized');\n\n        _initializeStewardLicense(\n            minter_,\n            addToCollectionMinter_,\n            steward_,\n            maxTokenCount_,\n            shouldMint,\n            name,\n            symbol,\n            baseURI\n        );\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n}\n"
    },
    "contracts/license/facets/NativeStewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { NativeStewardLicenseFacet } from './NativeStewardLicenseFacet.sol';\nimport { IStewardLicense } from '../IStewardLicense.sol';\n\ncontract NativeStewardLicenseMock is NativeStewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n\n    function burn(uint256 tokenId) external {\n        _burn(tokenId);\n    }\n\n    function testTriggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        IStewardLicense(address(this)).triggerTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC1155StewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC1155 } from '@solidstate/contracts/interfaces/IERC1155.sol';\nimport { IERC1155Metadata } from '@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol';\nimport { DiamondBaseStorage } from '@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol';\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\nimport { IERC1155Receiver } from '@solidstate/contracts/interfaces/IERC1155Receiver.sol';\nimport { WrappedStewardLicenseInternal } from '../WrappedStewardLicenseInternal.sol';\n\n/**\n * @title WrappedERC1155StewardLicenseFacet\n * @dev ERC-721 token license for Steward that wraps existing ERC-1155. Transfers are disabled during an auction.\n */\ncontract WrappedERC1155StewardLicenseFacet is\n    StewardLicenseInternal,\n    WrappedStewardLicenseInternal,\n    StewardLicenseBase,\n    IERC1155Receiver\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeWrappedStewardLicense(\n        address tokenAddress,\n        uint256 tokenId,\n        address minter_,\n        address addToCollectionMinter_,\n        address steward_,\n        uint256 maxTokenCount_,\n        bool shouldMint,\n        string memory name,\n        string memory symbol,\n        string memory tokenURI\n    ) external {\n        require(\n            !_isInitialized(),\n            'WrappedERC1155StewardLicenseFacet: already initialized'\n        );\n\n        _initializeWrappedLicense(tokenAddress, tokenId);\n        _initializeStewardLicense(\n            minter_,\n            addToCollectionMinter_,\n            steward_,\n            maxTokenCount_,\n            shouldMint,\n            name,\n            symbol,\n            tokenURI\n        );\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            value == 1,\n            'WrappedERC1155StewardLicenseFacet: can only receive one token'\n        );\n\n        require(\n            _isInitialized(),\n            'WrappedERC1155StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            id == _wrappedTokenId(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            ids.length == 1 && values.length == 1 && values[0] == 1,\n            'WrappedERC1155StewardLicenseFacet: can only receive one token'\n        );\n\n        require(\n            _isInitialized(),\n            'WrappedERC1155StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            ids[0] == _wrappedTokenId(),\n            'WrappedERC1155StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC1155StewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedERC1155StewardLicenseFacet } from './WrappedERC1155StewardLicenseFacet.sol';\n\ncontract WrappedERC1155StewardLicenseMock is WrappedERC1155StewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC721StewardLicenseFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC721Base, ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/base/ERC721Base.sol';\nimport { ERC721Enumerable } from '@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol';\nimport { IERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol';\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { IERC721Receiver } from '@solidstate/contracts/interfaces/IERC721Receiver.sol';\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { DiamondBaseStorage } from '@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol';\nimport { StewardLicenseInternal } from '../StewardLicenseInternal.sol';\nimport { WrappedStewardLicenseInternal } from '../WrappedStewardLicenseInternal.sol';\nimport { StewardLicenseBase } from '../StewardLicenseBase.sol';\n\n/**\n * @title WrappedERC721StewardLicenseFacet\n * @dev ERC-721 token license for Steward that wraps existing ERC-721. Only a particular ERC721 transfer is accepted.\n */\ncontract WrappedERC721StewardLicenseFacet is\n    StewardLicenseInternal,\n    WrappedStewardLicenseInternal,\n    StewardLicenseBase,\n    IERC721Receiver\n{\n    /**\n     * @notice Initialize license\n     */\n    function initializeWrappedStewardLicense(\n        address tokenAddress,\n        uint256 tokenId,\n        address minter_,\n        address addToCollectionMinter_,\n        address steward_,\n        uint256 maxTokenCount_,\n        bool shouldMint,\n        string memory name,\n        string memory symbol,\n        string memory tokenURI\n    ) external {\n        require(\n            !_isInitialized(),\n            'WrappedERC721StewardLicenseFacet: already initialized'\n        );\n\n        _initializeWrappedLicense(tokenAddress, tokenId);\n        _initializeStewardLicense(\n            minter_,\n            addToCollectionMinter_,\n            steward_,\n            maxTokenCount_,\n            shouldMint,\n            name,\n            symbol,\n            tokenURI\n        );\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function minter() external view returns (address) {\n        return _minter();\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(\n            _isInitialized(),\n            'WrappedERC721StewardLicenseFacet: must be initialized'\n        );\n\n        require(\n            msg.sender == _wrappedTokenAddress(),\n            'WrappedERC721StewardLicenseFacet: cannot accept this token address'\n        );\n\n        require(\n            tokenId == _wrappedTokenId(),\n            'WrappedERC721StewardLicenseFacet: cannot accept this token ID'\n        );\n\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/license/facets/WrappedERC721StewardLicenseMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedERC721StewardLicenseFacet } from './WrappedERC721StewardLicenseFacet.sol';\n\ncontract WrappedERC721StewardLicenseMock is WrappedERC721StewardLicenseFacet {\n    function mint(address account, uint256 tokenId) external {\n        _mint(account, tokenId);\n    }\n}\n"
    },
    "contracts/license/IStewardLicense.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol';\n\n/**\n * @title IStewardLicense\n */\ninterface IStewardLicense is IERC721, IERC721Metadata {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool);\n\n    /**\n     * @notice Get max token count\n     */\n    function maxTokenCount() external view returns (uint256);\n}\n"
    },
    "contracts/license/StewardLicenseBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseInternal } from './StewardLicenseInternal.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IPeriodicAuctionReadable } from '../auction/IPeriodicAuctionReadable.sol';\n\n/**\n * @title StewardLicenseBase\n */\nabstract contract StewardLicenseBase is IERC721, StewardLicenseInternal {\n    /**\n     * @notice Trigger transfer of license\n     */\n    function triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        require(\n            msg.sender == address(this),\n            'NativeStewardLicense: Trigger transfer can only be called from another facet'\n        );\n\n        _triggerTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @notice Initial bidder can mint token if it doesn't exist\n     */\n    function mintToken(address to, uint256 tokenId) external {\n        require(\n            msg.sender ==\n                IPeriodicAuctionReadable(address(this)).initialBidder(),\n            'StewardLicenseFacet: only initial bidder can mint token'\n        );\n        //slither-disable-next-line timestamp\n        require(\n            block.timestamp <\n                IPeriodicAuctionReadable(address(this))\n                    .initialPeriodStartTime(),\n            'StewardLicenseFacet: cannot mint after initial period start time'\n        );\n        require(!_exists(tokenId), 'StewardLicenseFacet: Token already exists');\n\n        _triggerTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @notice Add token to collection\n     */\n    function addTokenToCollection(\n        address to,\n        string memory tokenURI,\n        uint256 tokenInitialPeriodStartTime\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        _addTokenToCollection(to, tokenURI, tokenInitialPeriodStartTime);\n    }\n\n    /**\n     * @notice Add tokens to collection with to\n     */\n    function addTokensToCollection(\n        address[] memory to,\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        require(\n            to.length == tokenURIs.length &&\n                to.length == tokenInitialPeriodStartTimes.length,\n            'StewardLicenseFacet: input array length mismatch'\n        );\n\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            _addTokenToCollection(\n                to[i],\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection\n     */\n    function addTokensToCollection(\n        string[] memory tokenURIs,\n        uint256[] memory tokenInitialPeriodStartTimes,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            address to;\n            if (shouldMint) {\n                to = _initialSteward();\n            } else {\n                to = address(0);\n            }\n            _addTokenToCollection(\n                to,\n                tokenURIs[i],\n                tokenInitialPeriodStartTimes[i]\n            );\n        }\n    }\n\n    /**\n     * @notice Add tokens to collection with baseURI\n     */\n    function addTokensWithBaseURIToCollection(\n        uint32 amount,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        string memory baseURI,\n        bool shouldMint\n    ) external onlyRole(ADD_TOKEN_TO_COLLECTION_ROLE) {\n        for (uint32 i = 0; i < amount; i++) {\n            _addTokenWithBaseURIToCollection(\n                baseURI,\n                shouldMint,\n                initialPeriodStartTime + (initialPeriodStartTimeOffset * i)\n            );\n        }\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function maxTokenCount() external view returns (uint256) {\n        return _maxTokenCount();\n    }\n\n    /**\n     * @notice Check if token exists\n     */\n    function exists(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n}\n"
    },
    "contracts/license/StewardLicenseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { StewardLicenseStorage } from './StewardLicenseStorage.sol';\nimport { ERC721Base, ERC721BaseInternal } from '@solidstate/contracts/token/ERC721/base/ERC721Base.sol';\nimport { ERC721Enumerable } from '@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol';\nimport { ERC721Metadata } from '@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol';\nimport { ERC721MetadataStorage } from '@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol';\nimport { ERC165Base } from '@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol';\nimport { IERC165 } from '@solidstate/contracts/interfaces/IERC165.sol';\nimport { IERC721 } from '@solidstate/contracts/interfaces/IERC721.sol';\nimport { IPeriodicAuctionReadable } from '../auction/IPeriodicAuctionReadable.sol';\nimport { UintUtils } from '@solidstate/contracts/utils/UintUtils.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\nimport { EnglishPeriodicAuctionStorage } from '../auction/EnglishPeriodicAuctionStorage.sol';\n\n/**\n * @title StewardLicenseInternal\n */\nabstract contract StewardLicenseInternal is\n    ERC721Base,\n    ERC721Enumerable,\n    ERC721Metadata,\n    ERC165Base,\n    AccessControlInternal\n{\n    using UintUtils for uint256;\n\n    // Add token role\n    bytes32 internal constant ADD_TOKEN_TO_COLLECTION_ROLE =\n        keccak256('StewardLicenseBase.ADD_TOKEN_TO_COLLECTION_ROLE');\n\n    /**\n     * @notice Initialize license\n     */\n    function _initializeStewardLicense(\n        address minter,\n        address addToCollectionMinter,\n        address initialSteward,\n        uint256 maxTokenCount,\n        bool shouldMint,\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) internal {\n        StewardLicenseStorage.Layout storage l = StewardLicenseStorage.layout();\n\n        l.isInitialized = true;\n        l.initialSteward = initialSteward;\n        l.minter = minter;\n        l.maxTokenCount = maxTokenCount;\n\n        // Initialize ERC721\n        ERC721MetadataStorage.Layout storage ls = ERC721MetadataStorage\n            .layout();\n        ls.name = name;\n        ls.symbol = symbol;\n        ls.baseURI = baseURI;\n\n        _setSupportsInterface(type(IERC165).interfaceId, true);\n        _setSupportsInterface(type(IERC721).interfaceId, true);\n        _grantRole(ADD_TOKEN_TO_COLLECTION_ROLE, addToCollectionMinter);\n\n        if (shouldMint) {\n            // Mint tokens\n            for (uint256 i = 0; i < maxTokenCount; i++) {\n                _mint(initialSteward, i);\n            }\n        }\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return StewardLicenseStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get minter\n     */\n    function _minter() internal view returns (address) {\n        return StewardLicenseStorage.layout().minter;\n    }\n\n    /**\n     * @notice Get initial steward\n     */\n    function _initialSteward() internal view returns (address) {\n        return StewardLicenseStorage.layout().initialSteward;\n    }\n\n    /**\n     * @notice Trigger transfer\n     */\n    function _triggerTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        if (!_exists(tokenId)) {\n            // Mint token\n            _mint(to, tokenId);\n        } else {\n            // Safe transfer is not needed. If receiver does not implement ERC721Receiver, next auction can still happen. This prevents a failed transfer from locking up license\n            _transfer(from, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Get max token count\n     */\n    function _maxTokenCount() internal view returns (uint256) {\n        return StewardLicenseStorage.layout().maxTokenCount;\n    }\n\n    /**\n     * @notice Add token to collection\n     */\n    function _addTokenToCollection(\n        address to,\n        string memory tokenURI,\n        uint256 tokenInitialPeriodStartTime\n    ) internal {\n        StewardLicenseStorage.Layout storage l = StewardLicenseStorage.layout();\n\n        uint256 newTokenId = l.maxTokenCount;\n\n        // Increment max token count\n        l.maxTokenCount += 1;\n\n        // Override metadata\n        ERC721MetadataStorage.layout().tokenURIs[newTokenId] = tokenURI;\n\n        // Override auction start time\n        EnglishPeriodicAuctionStorage.layout().tokenInitialPeriodStartTime[\n            newTokenId\n        ] = tokenInitialPeriodStartTime;\n\n        if (to != address(0)) {\n            // Mint token\n            _mint(to, newTokenId);\n        }\n    }\n\n    /**\n     * @notice Add token to collection\n     */\n    function _addTokenWithBaseURIToCollection(\n        string memory _baseURI,\n        bool shouldMint,\n        uint256 tokenInitialPeriodStartTime\n    ) internal {\n        StewardLicenseStorage.Layout storage l = StewardLicenseStorage.layout();\n\n        uint256 newTokenId = l.maxTokenCount;\n\n        // Increment max token count\n        l.maxTokenCount += 1;\n\n        // Override metadata\n        ERC721MetadataStorage.layout().tokenURIs[newTokenId] = string(\n            abi.encodePacked(_baseURI, newTokenId.toString())\n        );\n\n        // Override auction start time\n        EnglishPeriodicAuctionStorage.layout().tokenInitialPeriodStartTime[\n            newTokenId\n        ] = tokenInitialPeriodStartTime;\n\n        if (shouldMint) {\n            // Mint token\n            _mint(l.initialSteward, newTokenId);\n        }\n    }\n\n    /**\n     * @notice Override token URI\n     * @return token URI\n     */\n    function _tokenURI(\n        uint256 tokenId\n    ) internal view override returns (string memory) {\n        StewardLicenseStorage.Layout storage licenseL = StewardLicenseStorage\n            .layout();\n\n        if (tokenId >= licenseL.maxTokenCount)\n            revert ERC721Metadata__NonExistentToken();\n\n        ERC721MetadataStorage.Layout storage metadataL = ERC721MetadataStorage\n            .layout();\n\n        string memory tokenIdURI = metadataL.tokenURIs[tokenId];\n        string memory baseURI = metadataL.baseURI;\n\n        if (bytes(tokenIdURI).length > 0) {\n            return tokenIdURI;\n        } else {\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\n        }\n    }\n\n    /**\n     * @notice Disable transfers if during auction period\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\n        // Disable transfers if not mint\n        if (from != address(0x0)) {\n            // External call is to known contract\n            //slither-disable-next-line calls-loop\n            bool isAuctionPeriod = IPeriodicAuctionReadable(address(this))\n                .isAuctionPeriod(tokenId);\n            require(\n                !isAuctionPeriod,\n                'StewardLicenseFacet: Cannot transfer during auction period'\n            );\n        }\n\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/license/StewardLicenseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title StewardLicenseStorage\n */\nlibrary StewardLicenseStorage {\n    struct Layout {\n        bool isInitialized;\n        address initialSteward;\n        address minter;\n        uint256 maxTokenCount;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.StewardLicenseStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        //slither-disable-next-line assembly\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/license/WrappedStewardLicenseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { WrappedStewardLicenseStorage } from './WrappedStewardLicenseStorage.sol';\n\n/**\n * @title WrappedStewardLicenseInternal\n */\nabstract contract WrappedStewardLicenseInternal {\n    /**\n     * @notice Initialize license\n     */\n    function _initializeWrappedLicense(\n        address wrappedTokenAddress,\n        uint256 wrappedTokenId\n    ) internal {\n        WrappedStewardLicenseStorage.Layout\n            storage l = WrappedStewardLicenseStorage.layout();\n\n        l.wrappedTokenAddress = wrappedTokenAddress;\n        l.wrappedTokenId = wrappedTokenId;\n    }\n\n    /**\n     * @notice Get wrapped token address\n     */\n    function _wrappedTokenAddress() internal view returns (address) {\n        return WrappedStewardLicenseStorage.layout().wrappedTokenAddress;\n    }\n\n    /**\n     * @notice Get wrapped token ID\n     */\n    function _wrappedTokenId() internal view returns (uint256) {\n        return WrappedStewardLicenseStorage.layout().wrappedTokenId;\n    }\n}\n"
    },
    "contracts/license/WrappedStewardLicenseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title WrappedStewardLicenseStorage\n */\nlibrary WrappedStewardLicenseStorage {\n    struct Layout {\n        address wrappedTokenAddress;\n        uint256 wrappedTokenId;\n    }\n\n    bytes32 private constant STORAGE_SLOT =\n        keccak256('pcoart.contracts.storage.WrappedStewardLicenseStorage');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        //slither-disable-next-line assembly\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/pco/IPeriodicPCOParamsReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title IPeriodicPCOParamsReadable\n */\ninterface IPeriodicPCOParamsReadable {\n    /**\n     * @notice Get license period\n     */\n    function licensePeriod() external view returns (uint256);\n\n    /**\n     * @notice Get fee numerator\n     */\n    function feeNumerator() external view returns (uint256);\n\n    /**\n     * @notice Get fee denominator\n     */\n    function feeDenominator() external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
